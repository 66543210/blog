

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn4.iconfinder.com/data/icons/gaming-fill/320/pokeball_pokemon_gaming_gamer_game_video-256.png">
  <link rel="icon" href="https://cdn4.iconfinder.com/data/icons/gaming-fill/320/pokeball_pokemon_gaming_gamer_game_video-256.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="button">
  <meta name="keywords" content="">
  
  <title>夯实基础-HTML/CSS - Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      
        
          
        
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism.min.css" />
      
      
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css" />
      
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"66543210.github.io","root":"/blog/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>HelloWorld</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/booknote/">
                <i class="iconfont icon-user-fill"></i>
                Note
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="夯实基础-HTML/CSS">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-05 15:07" pubdate>
        June 5, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      127
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">夯实基础-HTML/CSS</h1>
            
            <div class="markdown-body">
              <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>HTML不是一门编程语言，而是一种用于定义内容结构的<em>标记语言</em>。</strong></p>
<p>HTML 由一系列的<strong>元素</strong>组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作</p>
<ul>
<li><p>空元素</p>
</li>
<li><p>```html</p>
<img src="images/firefox-icon.png" srcset="/blog/img/loading.gif" lazyload alt="测试图片">
// 本元素包含两个属性，但是并没有 </img> 结束标签，元素里也没有内容。这是因为图像元素不需要通过内容来产生效果，它的作用是向其所在的位置嵌入一个图像。
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">
- &#96;&lt;!DOCTYPE html&gt;&#96; — 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991&#x2F;92 年）之时，&#96;DOCTYPE&#96; 用来链接一些 HTML 编写守则，比如自动查错之类。&#96;DOCTYPE&#96; 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。

- &#96;&#96;&#96;html
  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; — 该元素指定文档使用 UTF-8 字符编码 </code></pre></div></li>
<li><p> <code>&lt;ul&gt;</code>-<strong>无序列表（Unordered List）</strong></p>
</li>
<li><p><code>&lt;ol&gt;</code>-<strong>有序列表（Ordered List)</strong></p>
</li>
<li><p>```html<br>HTML中，除了<img><input><link><hr><video><audio>等标签，其它标签是不能自动闭合的</p>
<script>和</script>必须分开，否则会导致javascript代码无法执行
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">
- 语义类标签，它们的特点是视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义，比如大家会经常见到的 section、nav、p，这些都是语义类的标签。

- &#96;&#96;&#96;html
  &#x2F;&#x2F; &lt;rb&gt; &lt;rt&gt; &lt;rp&gt;, &lt;rb&gt; - 下方内容主体， &lt;rt&gt; - 上方标注内容 &lt;rp&gt; - 当浏览器不兼容时备选显示内容
  &lt;ruby&gt;
      &lt;rb&gt;注释&lt;&#x2F;rb&gt;
      &lt;rt&gt;zhushi&lt;&#x2F;rt&gt;
      &lt;rp&gt;备选&lt;&#x2F;rp&gt;
  &lt;&#x2F;ruby&gt;
    
    &lt;ruby&gt;
    汉 &lt;rp&gt;(&lt;&#x2F;rp&gt;&lt;rt&gt;Han&lt;&#x2F;rt&gt;&lt;rp&gt;)&lt;&#x2F;rp&gt;
    字 &lt;rp&gt;(&lt;&#x2F;rp&gt;&lt;rt&gt;zi&lt;&#x2F;rt&gt;&lt;rp&gt;)&lt;&#x2F;rp&gt;
  &lt;&#x2F;ruby&gt;</code></pre></div></li>
<li><ruby>
    <rb>注释</rb>
    <rt>zhushi</rt>
    <rp>备选</rp>
</ruby></li>
<li><ruby>
  汉 <rp>(</rp><rt>Han</rt><rp>)</rp>
  字 <rp>(</rp><rt>zi</rt><rp>)</rp>
</ruby></li>
</ul>
<p>abbr 标签表示缩写</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;abbr title&#x3D;&quot;World Wide Web&quot;&gt;WWW&lt;&#x2F;abbr&gt;.</code></pre></div>

<p><abbr title="World Wide Web">WWW</abbr>.</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;hr&gt;&lt;&#x2F;hr&gt;
横向分割线</code></pre></div>



<hr></hr>

<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;blockquote&gt;blockquote&lt;&#x2F;blockquote&gt;
&lt;q&gt;q&lt;&#x2F;q&gt;
&lt;cite&gt;cite&lt;&#x2F;cite&gt;</code></pre></div>

<blockquote>blockquote</blockquote>

<p><q>q</q></p>
<p><cite>cite</cite></p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;figure&gt; &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;6&#x2F;65&#x2F;Web_Index.svg&#x2F;2560px-Web_Index.svg.png&quot; style&#x3D;&quot;width:50%; height:50%&quot; &#x2F;&gt; &lt;figcaption&gt;The NeXT Computer used by Tim Berners-Lee at CERN.&lt;&#x2F;figcaption&gt;&lt;&#x2F;figure&gt;</code></pre></div>



<figure> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/Web_Index.svg/2560px-Web_Index.svg.png" srcset="/blog/img/loading.gif" lazyload style="width:50%; height:50%" /> <figcaption>The NeXT Computer used by Tim Berners-Lee at CERN.</figcaption></figure>

<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;dfn&gt;Internet&lt;&#x2F;dfn&gt;
定义词</code></pre></div>

<p><dfn>Internet</dfn></p>
<div class="code-wrapper"><pre><samp>
GET /home.html HTTP/1.1
Host: www.example.org
</samp></pre></div>

<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;pre&gt;&lt;samp&gt;
GET &#x2F;home.html HTTP&#x2F;1.1
Host: www.example.org
&lt;&#x2F;samp&gt;&lt;&#x2F;pre&gt;</code></pre></div>



<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;code&gt;123&lt;&#x2F;code&gt;
&lt;mark&gt;高亮&lt;&#x2F;mark&gt;
&lt;section&gt;456&lt;&#x2F;section&gt;</code></pre></div>

<p><code>123</code></p>
<p><mark>高亮</mark></p>
<section>456</section>

<iframe class="interactive" width="100%" height="375" src="https://interactive-examples.mdn.mozilla.net/pages/tabbed/samp.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe>



<p><code>语义标签</code>，对seo友好，不过开发上有点困难，如果是做web网页的话可以考虑，以增加自己seo的搜索权重</p>
<h4 id="head中的标签"><a href="#head中的标签" class="headerlink" title="head中的标签"></a>head中的标签</h4><ul>
<li>title标签</li>
<li>base标签：历史遗留标签，它的作用是给页面上所有的 URL 相对地址提供一个基础，但可能照成js的配合困难</li>
</ul>
<p>meta 标签：在 head 中可以出现任意多个 meta 标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;meta name&#x3D;application-name content&#x3D;&quot;lsForums&quot;&gt;
&lt;!--这里的 name 是一种比较自由的约定，HTTP 标准规定了一些 name 作为大家使用的共识，也鼓励大家发明自己的 name 来使用--&gt;
&lt;meta charset&#x3D;&quot;UTF-8&quot; &gt;
&lt;!--从 HTML5 开始，为了简化写法，meta 标签新增了 charset 属性--&gt;
&lt;!--它描述了HTML文档自身的编码形式, 建议放在head第一行，浏览器读到这个标签之前，处理的所有字符都是 ASCII 字符--&gt;</code></pre></div>

<p>meta的content是个复杂结构，键值对可以使用；分开</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&gt;</code></pre></div>

<p>这里只指定了两个属性，宽度和缩放，实际上 viewport 能控制的更多，它能表示的全部属性如下：</p>
<p>width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。</p>
<p>height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。</p>
<p>initial-scale：初始缩放比例。</p>
<p>minimum-scale：最小缩放比例。</p>
<p>maximum-scale：最大缩放比例。</p>
<p>user-scalable：是否允许用户缩放</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。它是一门样式表语言</p>
<ul>
<li>在<code>&lt;head&gt;</code>间引入<code>&lt;link href=&quot;styles/style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">选择器名称</th>
<th align="left">选择的内容</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">元素选择器（也称作标签或类型选择器）</td>
<td align="left">所有指定(该)类型的 HTML 元素（要考虑 HTML 或者 XML 元素的命名空间问题）</td>
<td align="left"><code>p</code> 选择 <code>&lt;p&gt;</code></td>
</tr>
<tr>
<td align="left">ID 选择器</td>
<td align="left">具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td>
<td align="left"><code>#my-id</code> 选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td>
</tr>
<tr>
<td align="left">类选择器</td>
<td align="left">具有特定类的元素（单一页面中，一个类可以有多个实例）</td>
<td align="left"><code>.my-class</code> 选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td>
</tr>
<tr>
<td align="left">属性选择器</td>
<td align="left">拥有特定属性的元素</td>
<td align="left"><code>img[src]</code> 选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code>而不是 <code>&lt;img&gt;</code></td>
</tr>
<tr>
<td align="left">伪（Pseudo）类选择器</td>
<td align="left">特定状态下的特定元素（比如鼠标指针悬停）</td>
<td align="left"><code>a:hover</code> 仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code>。</td>
</tr>
</tbody></table>
<p>svg 和 HTML 中都有 a 元素，我们若要想区分选择 svg 中的 a 和 HTML 中的 a，就必须用带命名空间的类型选择器</p>
<div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">@namespace svg url(http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg);
@namespace html url(http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml);
svg|a &#123; stroke:blue; stroke-width:1;&#125;
html|a &#123; font-size:40px&#125;</code></pre></div>



<p><img src="https://mdn.mozillademos.org/files/9443/box-model.png" srcset="/blog/img/loading.gif" lazyload alt="three boxes sat inside one another. From outside to in they are labelled margin, border and padding"></p>
<blockquote>
<p>CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。</p>
</blockquote>
<h4 id="CSS的-规则"><a href="#CSS的-规则" class="headerlink" title="CSS的@规则"></a>CSS的@规则</h4><p>一个 <strong>at-rule</strong> 是一个CSS 语句以at符号开头, ‘<code>@</code>‘ (<code>U+0040 COMMERCIAL AT</code>), 后跟一个标识符，并包括直到下一个分号的所有内容, ‘<code>;</code>‘ (<code>U+003B SEMICOLON</code>), 或下一个CSS块，以先到者为准。</p>
<p>下面是一些 @规则, 由它们的标示符指定, 每种规则都有不同的语法:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset"><code>@charset</code></a>, 定义样式表使用的字符集.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import"><code>@import</code></a>, 告诉 CSS 引擎引入一个外部样式表.</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。</code></pre></div></li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace"><code>@namespace</code></a>, 告诉 CSS 引擎必须考虑XML命名空间。</p>
</li>
<li><p>嵌套@规则, 是嵌套语句的子集,不仅可以作为样式表里的一个语句，也可以用在条件规则组里：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"><code>@media</code></a>, 如果满足媒介查询的条件则条件规则组里的规则生效。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page"><code>@page</code></a>, 描述打印文档时布局的变化.</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>, 描述将下载的外部的字体。 </li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><code>@keyframes</code></a>, 描述 CSS 动画的中间步骤 . </li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports"><code>@supports</code></a>, 如果满足给定条件则条件规则组里的规则生效。 </li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document"><code>@document</code></a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 <em>(推延至 CSS Level 4 规范)</em></li>
</ul>
</li>
</ul>
<h4 id="CSS的普通规则Qualified-Rule"><a href="#CSS的普通规则Qualified-Rule" class="headerlink" title="CSS的普通规则Qualified Rule"></a>CSS的普通规则Qualified Rule</h4><p><font color=darkred>属性是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。</font></p>
<div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 在css的Variables 标准中，以双中划线开头的属性被当作变量，与之配合的是var函数
:root &#123;
  --main-color: #06c;
  --accent-color: #006;
&#125;
&#x2F;* The rest of the CSS file *&#x2F;
#foo h1 &#123;
  color: var(--main-color);
&#125;</code></pre></div>

<p>CSS 属性值可能是以下类型。</p>
<ul>
<li>CSS 范围的关键字：initial，unset，inherit，任何属性都可以的关键字。</li>
<li>字符串：比如 content 属性。</li>
<li>URL：使用 url() 函数的 URL 值。</li>
<li>整数 / 实数：比如 flex 属性。</li>
<li>维度：单位的整数 / 实数，比如 width 属性。</li>
<li>百分比：大部分维度都支持。</li>
<li>颜色：比如 background-color 属性。</li>
<li>图片：比如 background-image 属性。</li>
<li>2D 位置：比如 background-position 属性。</li>
<li>函数：来自函数的值，比如 transform 属性。</li>
</ul>
<p><strong>伪类选择器</strong></p>
<p>伪类选择器是一系列由 CSS 规定好的选择器，它们以冒号开头。伪类选择器有普通型和函数型两种。</p>
<ul>
<li>:root 伪类表示树的根元素</li>
<li>:empty 伪类表示没有子节点的元素，这里有个例外就是子节点为空白文本节点的情况。</li>
<li>:nth-child 和 :nth-last-child 这是两个函数型的伪类，CSS 的 An+B 语法设计的是比较复杂的</li>
<li><img src="https://static001.geekbang.org/resource/image/1e/a9/1ebdba2978a22c13844d108318b271a9.png" srcset="/blog/img/loading.gif" lazyload alt="img" style="zoom:80%;" /></li>
<li>:nth-last-child 的区别仅仅是从后往前数。</li>
<li>:first-child :last-child 分别表示第一个和最后一个元素</li>
<li>:only-child 按字面意思理解即可，选中唯一一个子元素。</li>
</ul>
<p>of-type 系列，是一个变形的语法糖，S:nth-of-type(An+B) 是:nth-child(|An+B| of S) 的另一种写法。以此类推，还有 nth-last-of-type、first-of-type、last-of-type、only-of-type</p>
<p><strong>复杂选择器</strong></p>
<p>复杂选择器是针对节点关系的选择，它规定了五种连接符号。</p>
<ul>
<li>“空格”：后代，表示选中所有符合条件的后代节点，<font color=red>包括子孙子的所有后代</font> 例如“ .a .b ”表示选中所有具有 class 为 a 的后代节点中 class 为 b 的节点。</li>
<li>“&gt;” ：子代，表示选中符合条件的子节点，<font color=red>第一代子元素，孙子这些都不算</font></li>
<li>“<del>” : 后继，表示选中所有符合条件的后继节点，<font color=red>后继节点即跟当前节点具有同一个父元素，并出现在它之后的节点</font>，<font color=blue>弟弟节点</font>，例如“ .a</del>.b ”表示选中所有具有 class 为 a 的后继中，class 为 b 的节点。</li>
<li>“+”：直接后继<font color=blue>(第一个弟弟节点)</font>，表示选中符合条件的直接后继节点，直接后继节点即 nextSlibling。例如 “.a+.b ”表示选中所有具有 class 为 a 的下一个 class 为 b 的节点。</li>
<li>“||”：列选择器，表示选中对应列中符合条件的单元格。<font color=dark>很诡异的选择器</font></li>
</ul>
<p><img src="https://image.zhangxinxu.com/image/blog/201902/table-col.png" srcset="/blog/img/loading.gif" lazyload alt="表格中的整列样式控制"></p>
<p><strong>css规则优先级</strong></p>
<p>CSS 标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。</p>
<ul>
<li>id 选择器的数目记为 a；</li>
<li>伪类选择器和 class 选择器的数目记为 b；</li>
<li>伪元素选择器和标签选择器数目记为 c；</li>
<li>“*” 不影响优先级。</li>
</ul>
<p>CSS 标准建议用一个足够大的进制，获取“ a-b-c ”来表示选择器优先级。</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">specificity &#x3D; base * base * a + base * b + c
&#x2F;&#x2F; 其中为了避嫌base*b追上base*base*a，base需要是一个‘足够大’的正整数，目前是65536</code></pre></div>

<p>对于同一优先级的规则，采用<code>后面覆盖前面</code>的规则</p>
<p>!import &gt; 内联样式 &gt; ID选择器 &gt; 伪类 &gt; 属性选择器 &gt; 类选择器 &gt; 元素(类型)选择器 &gt; 通用选择器</p>
<p>伪元素的语法跟伪类相似，但是实际产生的效果是把不存在的元素硬选出来。这一点就与伪类不太一样了</p>
<blockquote>
<p> 伪类(如:first-child)的操作对象是文档树中已有的元素，而伪元素(如:first-letter)则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素</p>
<p>CSS3 规范中的要求使用双冒号 (::) 表示伪元素，以此来区分伪元素和伪类，比如::before 和::after 等伪元素使用双冒号 (::) ，    :hover 和:active 等伪类使用单冒号 (:)。</p>
</blockquote>
<p><img src="http://www.alloyteam.com/wp-content/uploads/2016/05/%E4%BC%AA%E7%B1%BB.png" srcset="/blog/img/loading.gif" lazyload alt="伪类"></p>
<p><img src="http://www.alloyteam.com/wp-content/uploads/2016/05/%E4%BC%AA%E5%85%83%E7%B4%A0.png" srcset="/blog/img/loading.gif" lazyload alt="伪元素"></p>
<h4 id="css中的超链接家族"><a href="#css中的超链接家族" class="headerlink" title="css中的超链接家族"></a>css中的超链接家族</h4><p><img src="https://static001.geekbang.org/resource/image/ca/51/caab7832c425b3af2b3adae747e6f551.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>map标签和area标签</p>
<p>
 Please select a shape:
 <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSSZtgg57oskmtYT9w5W_uR99u4xgRIq5osqnjWZFrt3P61K0-P1QWXrBiPNU8SJgy6Kdb1aNSpMq4&usqp=CAU" srcset="/blog/img/loading.gif" lazyload usemap="#shapes"
      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- the hole in the red box -->
      <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">
  <area shape=circle coords="200,75,50" href="green.html" alt="Green circle.">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle.">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="Yellow star.">
 </map>
</p>



<p>简单来说就是一个img标签可以指定一个map(使用usemap)，然后在<code>&lt;map&gt;</code>标签中定义若干个<code>&lt;area&gt;</code>，而<code>&lt;area&gt;</code>指定img中的某个区域的点击跳转事件，某种意义上弥补了a标签的不足，因为a标签不能嵌套，area可以，同时map下的area不一定要是第一个子元素可以说孙子节点</p>
<blockquote>
<p>如果<code>&lt;area&gt;</code>要想和图片热点关联，祖先元素<code>&lt;map&gt;</code>是不可缺少的，但是不一定非得直接父子关系。<code>&lt;map&gt;</code>和<code>&lt;area&gt;</code>之间再嵌套个<code>&lt;div&gt;</code>什么的功能也是正常的</p>
<p><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/</a></p>
</blockquote>
<blockquote>
<p>补充a标签的target </p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_blank</td>
<td align="left">在新窗口中打开被链接文档。</td>
</tr>
<tr>
<td align="left">_self</td>
<td align="left">在被点击时的同一框架中打开被链接文档（默认）。</td>
</tr>
<tr>
<td align="left">_parent</td>
<td align="left">在父框架中打开被链接文档。</td>
</tr>
<tr>
<td align="left">_top</td>
<td align="left">在窗口主体中打开被链接文档。</td>
</tr>
</tbody></table>
<p>grid网格布局</p>
<p>flex布局可以看成一维布局，而grid就是二维布局</p>
<p>picture 元素可以根据屏幕的条件为其中的 img 元素提供不同的源</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;picture&gt;
  &lt;source srcset&#x3D;&quot;image-wide.png&quot; media&#x3D;&quot;(min-width: 600px)&quot;&gt;
  &lt;img src&#x3D;&quot;image-narrow.png&quot;&gt;
&lt;&#x2F;picture&gt;</code></pre></div>

<h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p>animation的基本用法</p>
<div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">
@keyframes mykf
&#123;
  from &#123;background: red;&#125;
  to &#123;background: yellow;&#125;
&#125;

div
&#123;
    animation:mykf 5s infinite;
&#125;</code></pre></div>



<h3 id="css三大基本问题"><a href="#css三大基本问题" class="headerlink" title="css三大基本问题"></a>css三大基本问题</h3><ul>
<li>垂直居中问题</li>
<li>两列等高问题</li>
<li>自适应宽问题</li>
</ul>
<p>flex的align-items: stretch;</p>
<div><iframe class="interactive" height="390" src="https://interactive-examples.mdn.mozilla.net/pages/css/align-items.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe></div>

<h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>模拟抛物线小球</p>
<style>
    .ball {
        width:10px;
        height:10px;
        background-color:black;
        border-radius:5px;
        position:absolute;
        left:0;
        top:0;
        transform:translateY(180px);
</style>
<script>
    function generateCubicBezier (v, g, t){
    var a = v / g;
    var b = t + v / g;
    return [[(a / 3 + (a + b) / 3 - a) / (b - a), (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)],
        [(b / 3 + (a + b) / 3 - a) / (b - a), (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)]];
}
function createBall() {
  var ball = document.createElement("div");
  var t = Number(document.getElementById("t").value);
  var vx = Number(document.getElementById("vx").value);
  var vy = Number(document.getElementById("vy").value);
  var g = Number(document.getElementById("g").value);
  ball.className = "ball";
  document.body.appendChild(ball)
  ball.style.transition = `left linear ${t}s, top cubic-bezier(${generateCubicBezier(vy, g, t)}) ${t}s`;
  setTimeout(function(){ 
    ball.style.left = `${vx * t}px`; 
    ball.style.top = `${vy * t + 0.5 * g * t * t}px`; 
  }, 100);
  setTimeout(function(){ document.body.removeChild(ball); }, t * 1000);
}
</script>
<body>
    <label>运动时间：<input value="3.6" type="number" id="t" />s</label><br/>
  <label>初速度：<input value="-21" type="number" id="vy" /> px/s</label><br/>
  <label>水平速度：<input value="21" type="number" id="vx" /> px/s</label><br/>
  <label>重力：<input value="10" type="number" id="g" /> px/s²</label><br/>
  <button onclick="createBall()">来一个球</button>
</body>



<p>用 JavaScript 来实现一个 transition 函数，用它来跟 CSS 的 transition 来做一下对比</p>
<h3 id="css颜色"><a href="#css颜色" class="headerlink" title="css颜色"></a>css颜色</h3><p>background-image这样的属性，可以设为渐变</p>
<p>线性渐变的写法是：</p>
<div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">linear-gradient(direction, color-stop1, color-stop2, ...);</code></pre></div>

<p>真正的金色</p>
<div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">background: linear-gradient(45deg, gold 10%, yellow 50%, gold 90%); </code></pre></div>

<div id="grad1" style="height: 20px; width: 20px;background: linear-gradient(45deg, gold 10%, yellow 50%, gold 90%); "></div>

<p><img src="https://static001.geekbang.org/resource/image/0f/ac/0f6f4cc6d564df9986e0108cb8a427ac.jpg" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>把鸟换成红色</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
  &lt;title&gt;Document&lt;&#x2F;title&gt;
  &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;
    .bird &#123;
      width: 400px;
      height: calc(1440 * 400 &#x2F; 1920 * 1px);
    &#125;
    canvas.bird &#123;
      background: #ccc;
    &#125;
  &lt;&#x2F;style&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
  &lt;img id&#x3D;&quot;img&quot; class&#x3D;&quot;bird&quot; src&#x3D;&quot;.&#x2F;bird.jpg&quot;&gt;
  &lt;canvas id&#x3D;&quot;canvas&quot; width&#x3D;&quot;1920&quot; height&#x3D;&quot;1440&quot; class&#x3D;&quot;bird&quot;&gt;&lt;&#x2F;canvas&gt;

  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;
    let canvas &#x3D; document.getElementById(&#39;canvas&#39;)
    let ctx &#x3D; canvas.getContext(&#39;2d&#39;)
    let img &#x3D; document.getElementById(&#39;img&#39;)
    img.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;
      ctx.drawImage(img, 0, 0)

      let imageData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height)
      let data &#x3D; imageData.data

      for (let i &#x3D; 0; i &lt; data.length; i +&#x3D; 4) &#123;
        if (isBird(data, i, canvas.width, canvas.height)) &#123;
          ;[data[i], data[i + 1]] &#x3D; [data[i + 1] * 1.2, data[i]]
        &#125;
      &#125;

      ctx.putImageData(imageData, 0, 0)
    &#125;)

    function isBird (data, i, width, height) &#123;
      let r &#x3D; data[i]
      let g &#x3D; data[i + 1]
      let b &#x3D; data[i + 2]

      let [h, s, l] &#x3D; rgb2hsl(r, g, b)
      return h &lt; 200 &amp;&amp; h &gt; 80 &amp;&amp; s &gt; 0.23 &amp;&amp; l &lt; 0.84
    &#125;

    function rgb2hsl (r, g, b) &#123;
      let r1 &#x3D; r &#x2F; 255
      let g1 &#x3D; g &#x2F; 255
      let b1 &#x3D; b &#x2F; 255

      let min &#x3D; Math.min(r1, g1, b1)
      let max &#x3D; Math.max(r1, g1, b1)

      let l &#x3D; (min + max) &#x2F; 2
      let s
      let h

      if (l &lt; 0.5) &#123;
        s &#x3D; (max - min) &#x2F; (max + min)
      &#125; else &#123;
        s &#x3D; (max - min) &#x2F; (2 - max - min)
      &#125;

      if (max &#x3D;&#x3D;&#x3D; r1) &#123;
        h &#x3D; (r1 - b1) &#x2F; (max - min)
      &#125; else if (max &#x3D;&#x3D;&#x3D; g1) &#123;
        h &#x3D; 2 + (b1 - r1) &#x2F; (max - min)
      &#125; else if (max &#x3D;&#x3D;&#x3D; b1) &#123;
        h &#x3D; 4 + (r1 - g1) &#x2F; (max - min)
      &#125;

      h *&#x3D; 60

      while (h &lt; 0) &#123;
        h +&#x3D; 360
      &#125;

      return [h, s, l]
    &#125;
  &lt;&#x2F;script&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre></div>

<p>或</p>
<div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">filter: hue-rotate(240deg); &#x2F;&#x2F; 根据HSL色环，绿色在120deg的位置，要变成红色，把色相顺时针旋转240deg或者逆时针120deg即可</code></pre></div>

<p>filter滤镜属性，对元素进行效果叠加，有blur等方法，其中<code>hue-rotate</code>为色调旋转，可以使用<code>hue-rotate(angle)</code>angle为对应旋转的角度</p>
<h3 id="ARIA可访问性"><a href="#ARIA可访问性" class="headerlink" title="ARIA可访问性"></a>ARIA可访问性</h3><p>ARIA不会影响web的外观，但可以添加role使得屏幕阅读器使用者了解该内容的作用，在弹出的消息元素上添加role=alert就可以使得阅读器播报该内容</p>
<blockquote>
<p>但<strong>ARIA永远无法替代语义化HTML标签</strong>。</p>
</blockquote>
<h2 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h2><h3 id="建议用void-0替代undefined"><a href="#建议用void-0替代undefined" class="headerlink" title="建议用void 0替代undefined"></a>建议用void 0替代undefined</h3><p>因为undefined目前是一个全局变量而非关键字， 所以可能被串改</p>
<h3 id="js中的number精度"><a href="#js中的number精度" class="headerlink" title="js中的number精度"></a>js中的number精度</h3><blockquote>
<p> 表达范围 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数</p>
</blockquote>
<h3 id="正确比较0-1-0-2-等于0-3"><a href="#正确比较0-1-0-2-等于0-3" class="headerlink" title="正确比较0.1 + 0.2 等于0.3"></a>正确比较0.1 + 0.2 等于0.3</h3><p>由于受number的精度影响在js中以下代码是不成立的</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log( 0.1 + 0.2 &#x3D;&#x3D; 0.3);</code></pre></div>

<p>正确比较方式为</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;&#x3D; Number.EPSILON);</code></pre></div>

<p>通过js提供的最小精度来判断</p>
<h3 id="js数据类型上的装箱操作"><a href="#js数据类型上的装箱操作" class="headerlink" title="js数据类型上的装箱操作"></a>js数据类型上的装箱操作</h3><p>在js中可以直接在一些基本数据类型上使用对象方法，如string基本数据类型，可以使用.charAt()这些在String对象类型上的方法，是因为<code>.</code>运算符提供了装箱操作，会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法</p>
<h3 id="js的类型转换"><a href="#js的类型转换" class="headerlink" title="js的类型转换"></a>js的类型转换</h3><p>可以通过基本数据类型对应的类来执行装箱装换</p>
<p>强制生成Symbol对象</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var symbolObject &#x3D; (function()&#123; return this; &#125;).call(Symbol(&quot;a&quot;));

console.log(typeof symbolObject); &#x2F;&#x2F;object
console.log(symbolObject instanceof Symbol); &#x2F;&#x2F;true
console.log(symbolObject.constructor &#x3D;&#x3D; Symbol); &#x2F;&#x2F;true</code></pre></div>

<p>使用Object函数</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var symbolObject &#x3D; Object(Symbol(&quot;a&quot;));

console.log(typeof symbolObject); &#x2F;&#x2F;object
console.log(symbolObject instanceof Symbol); &#x2F;&#x2F;true
console.log(symbolObject.constructor &#x3D;&#x3D; Symbol); &#x2F;&#x2F;true</code></pre></div>

<p>拆箱装换</p>
<blockquote>
<p>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">@@toPrimitive Symbol</a></p>
<h3 id="基于对象的js和面向对象的其他"><a href="#基于对象的js和面向对象的其他" class="headerlink" title="基于对象的js和面向对象的其他"></a>基于对象的js和面向对象的其他</h3><blockquote>
<p>JavaScript 标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”</p>
</blockquote>
<p>对象的基本特征：标识性、状态和行为</p>
<blockquote>
<p>JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p>
</blockquote>
<blockquote>
<p>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。</p>
</blockquote>
<blockquote>
<p>JavaScript 用一组特征（attribute）来描述属性（property）</p>
</blockquote>
<p>这一点类同OC中的@property中使用的特性，即对一个属性本身的特点进行规定</p>
<p>数据属性的四个特性</p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值</li>
</ul>
<p>访问器（getter/setter）属性的特性</p>
<ul>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取特性getOwnPropertyDescriptor
    var o &#x3D; &#123; a: 1 &#125;;
    o.b &#x3D; 2;
    &#x2F;&#x2F;a和b皆为数据属性
    Object.getOwnPropertyDescriptor(o,&quot;a&quot;) &#x2F;&#x2F; &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;
    Object.getOwnPropertyDescriptor(o,&quot;b&quot;) &#x2F;&#x2F; &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;

&#x2F;&#x2F; 设置特性defineProperty

    var o &#x3D; &#123; a: 1 &#125;;
    Object.defineProperty(o, &quot;b&quot;, &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;);
    &#x2F;&#x2F;a和b都是数据属性，但特征值变化了
    Object.getOwnPropertyDescriptor(o,&quot;a&quot;); &#x2F;&#x2F; &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;
    Object.getOwnPropertyDescriptor(o,&quot;b&quot;); &#x2F;&#x2F; &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;
    o.b &#x3D; 3;
    console.log(o.b); &#x2F;&#x2F; 2</code></pre></div>

<p>==对象的property属性和私有字段[[property]]不是一个概念==</p>
<p>new 运算接受一个构造器和一组调用参数，实际上做了几件事：</p>
<ol>
<li>以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；</li>
<li>将 this 和调用参数传给构造器，执行；</li>
<li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li>
</ol>
<div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>
没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定[[prototype]]的方法（当时的 mozilla 提供了私有属性 __proto__，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 polyfill，见以下代码：</div>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object.create &#x3D; function(prototype)&#123;
    var cls &#x3D; function()&#123;&#125;
    cls.prototype &#x3D; prototype;
    return new cls;
&#125;</code></pre></div>



<h3 id="js的对象分类"><a href="#js的对象分类" class="headerlink" title="js的对象分类"></a>js的对象分类</h3><p>js的对象可以分为几类</p>
<ul>
<li>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">比如浏览器环境下window对象下又一些属性一部分来自js语言，一部分来自浏览器环境，js标准中规定了全局对象属性，W3C的各种标准中规定了Window对象的其他属性</code></pre></div>



<ul>
<li><p>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。</p>
<ul>
<li><p>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">它们通常扮演类似基础库的角色</code></pre></div>

<p>ECMA标准中提供的<a target="_blank" rel="noopener" href="https://262.ecma-international.org/9.0/#sec-well-known-intrinsic-objects">固有对象表</a>, 但并不完整</p>
</li>
<li><p>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</p>
<p><img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" srcset="/blog/img/loading.gif" lazyload alt="img"></p>
<p>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。</p>
<blockquote>
<p>函数对象的定义是：具有[[call]]私有字段的对象，构造器对象的定义是：具有私有字段[[construct]]的对象。</p>
</blockquote>
</li>
<li><p>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</p>
</li>
</ul>
</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function f()&#123;
    return 1;
&#125;
var v &#x3D; f(); &#x2F;&#x2F;把f作为函数调用
var o &#x3D; new f(); &#x2F;&#x2F;把f作为构造器调用</code></pre></div>

<p>我们大致可以认为，它们[[construct]]的执行过程如下：</p>
<ul>
<li>以 Object.prototype 为原型创建一个新对象；</li>
<li>以新对象为 this，执行函数的[[call]]；</li>
<li>如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li>
</ul>
<p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function cls()&#123;
    this.a &#x3D; 100;
    return &#123;
        getValue:() &#x3D;&gt; this.a
    &#125;
&#125;
var o &#x3D; new cls;
o.getValue(); &#x2F;&#x2F;100
&#x2F;&#x2F;a在外面永远无法访问到</code></pre></div>

<h3 id="promise和setInterval"><a href="#promise和setInterval" class="headerlink" title="promise和setInterval"></a>promise和setInterval</h3><blockquote>
<p>采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务</p>
</blockquote>
<blockquote>
<p>有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
</blockquote>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：</p>
<img src="https://static001.geekbang.org/resource/image/16/65/16f70a9a51a65d5302166b0d78414d65.jpg" srcset="/blog/img/loading.gif" lazyload alt="img" style="zoom:30%;" />



<blockquote>
<p>微任务总会在下一个宏任务之前执行，在本身所属的宏任务结束后立即执行</p>
<p>执行主线程宏任务(同步代码) -&gt; 执行并清空微任务队列 -&gt; 执行下一个宏任务</p>
</blockquote>
<p>Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。因此Promise.then的输出会在setTimeout前面</p>
<p>==微任务优先==</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 尽管c2是在d之后才添加的，但还是在d前输出，说明了微任务优先
    setTimeout(()&#x3D;&gt;console.log(&quot;d&quot;), 0)
    var r &#x3D; new Promise(function(resolve, reject)&#123;
        resolve()
    &#125;);
    r.then(() &#x3D;&gt; &#123; 
        var begin &#x3D; Date.now();
        while(Date.now() - begin &lt; 1000);
        console.log(&quot;c1&quot;) 
        new Promise(function(resolve, reject)&#123;
            resolve()
        &#125;).then(() &#x3D;&gt; console.log(&quot;c2&quot;))
    &#125;);
    &#x2F;&#x2F; c1
    &#x2F;&#x2F; c2
    &#x2F;&#x2F; d</code></pre></div>

<div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色</div>

<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function sleep(duration)&#123;
    return new Promise(function(resolve)&#123;
        setTimeout(resolve, duration);
    &#125;)
&#125;
async function changeColor(duration,color)&#123;
    document.getElementById(&quot;traffic-light&quot;).style.background &#x3D; color;
    await sleep(duration);

&#125;
async function main()&#123;
    while(true)&#123;
        await changeColor(3000,&quot;green&quot;);
        await changeColor(1000, &quot;yellow&quot;);
        await changeColor(2000, &quot;red&quot;);
    &#125;
&#125;
main()</code></pre></div>

<h3 id="闭包和执行上下文"><a href="#闭包和执行上下文" class="headerlink" title="闭包和执行上下文"></a>闭包和执行上下文</h3><img src="https://static001.geekbang.org/resource/image/68/52/68f50c00d475a7d6d8c7eef6a91b2152.png" srcset="/blog/img/loading.gif" lazyload alt="img" style="zoom:70%;" />





<blockquote>
<p>闭包其实只是一个绑定了执行环境的函数</p>
</blockquote>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。 在JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
</blockquote>
<p>古典的闭包定义中，闭包包含两个部分</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">闭包</a></p>
<ul>
<li><p>环境部分</p>
<ul>
<li><p>环境</p>
<p>函数的词法环境（执行上下文的一部分）</p>
</li>
<li><p>标识符列表</p>
<p>函数中用到的未声明的变量</p>
</li>
</ul>
</li>
<li><p>表达式部分: 函数体</p>
</li>
</ul>
<blockquote>
<p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。</p>
</blockquote>
<p>ES2018中的Realms组成</p>
<ol>
<li>a set of intrinsic objects(一组内置对象)</li>
<li>global environment （一个全局环境）</li>
<li>code （在上面这个全局环境中加载的所有代码）</li>
<li>state and resources （状态和资源）</li>
</ol>
<blockquote>
<p>对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。</p>
</blockquote>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">
var iframe &#x3D; document.createElement(&#39;iframe&#39;)
document.documentElement.appendChild(iframe)
iframe.src&#x3D;&quot;javascript:var b &#x3D; &#123;&#125;;&quot;

var b1 &#x3D; iframe.contentWindow.b;
var b2 &#x3D; &#123;&#125;;

console.log(typeof b1, typeof b2); &#x2F;&#x2F;object object

console.log(b1 instanceof Object, b2 instanceof Object); &#x2F;&#x2F;false true</code></pre></div>

<h3 id="js内的函数种类"><a href="#js内的函数种类" class="headerlink" title="js内的函数种类"></a>js内的函数种类</h3><ul>
<li><p>function声明的函数</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>生成器函数：用 function * 定义的函数</p>
</li>
<li><p>class内自定义的函数</p>
</li>
<li><p>class内自带的函数，如constructor</p>
</li>
<li><p>异步函数</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function foo()&#123;
    &#x2F;&#x2F; code
&#125;
const foo &#x3D; async () &#x3D;&gt; &#123;
    &#x2F;&#x2F; code
&#125;
async function foo*()&#123;
    &#x2F;&#x2F; code
&#125;</code></pre></div></li>
</ul>
<p>当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。</p>
<p><strong>关于var和funtion的变量提升</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(a)   &#x2F;&#x2F;undefined
var a&#x3D;&#39;我是谁&#39;
console.log(a)   &#x2F;&#x2F;&#39;我是谁&#39;</code></pre></div>

<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 实际执行过程相当于
var a;
console.log(a);
a&#x3D;&#39;我是谁&#39;
console.log(a)</code></pre></div>

<p>JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/e8/31/e8d8e96c983a832eb646d6c17ff3df31.jpg" srcset="/blog/img/loading.gif" lazyload alt="img" style="zoom:70%;" />

<p>当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]]私有属性。</p>
<p>[[thisMode]] 私有属性有三个取值。</p>
<ul>
<li>lexical：表示从上下文中找 this，这对应了箭头函数。</li>
<li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li>
<li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li>
</ul>
<p>call apple bind对于this的修改</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(a, b, c)&#123;
    console.log(this);
    console.log(a, b, c);
&#125;
foo.call(&#123;&#125;, 1, 2, 3);
foo.apply(&#123;&#125;, [1, 2, 3]);


&#x2F;&#x2F; bind生成一个绑定this的函数
foo.bind(&#123;&#125;, 1, 2, 3)();</code></pre></div>

<p><font color=blue>但是他们都无法改变箭头函数的this指向</font></p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var o &#x3D; &#123;
  a: 1
&#125;;
this.a &#x3D; 2;
(() &#x3D;&gt; &#123;console.log(this.a)&#125;).call(o);
(function () &#123;console.log(this.a)&#125;).call(o);

&#x2F;&#x2F; 2
&#x2F;&#x2F; 1</code></pre></div>

<h3 id="Completion-Record"><a href="#Completion-Record" class="headerlink" title="Completion Record"></a>Completion Record</h3><p>Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p>
<ul>
<li>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</li>
<li>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</li>
<li>[[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。</li>
</ul>
<p>语句的分类</p>
<img src="https://static001.geekbang.org/resource/image/98/d5/98ce53be306344c018cddd6c083392d5.jpg" srcset="/blog/img/loading.gif" lazyload alt="img" style="zoom:60%;" />



<p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。</p>
<p>这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。具体表现在chrom的调试器中<code>var a = 1</code>和<code>a = 1</code>的输出是不同的，前者属于声明式语句，后者为表达式</p>
<p>在try/catch语句中finally一点会执行，即使在try/catch中进行了return操作，不过若finally中也进行了return操作则会覆盖</p>
<p>关于</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">12.toString(); &#x2F;&#x2F;会报错
&#x2F;&#x2F; 12.toString() 他无法分辨你是想要创建一个小数位为toString()的数 还是创建一个12 然后调用toString()这种情况, 此时可以使用(12).toString(); 或12..toString(); 来明确token</code></pre></div>

<h3 id="js脚本和模块"><a href="#js脚本和模块" class="headerlink" title="js脚本和模块"></a>js脚本和模块</h3><img src="https://static001.geekbang.org/resource/image/43/44/43fdb35c0300e73bb19c143431f50a44.jpg" srcset="/blog/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<h3 id="js运算符的结合方向和及优先级"><a href="#js运算符的结合方向和及优先级" class="headerlink" title="js运算符的结合方向和及优先级"></a>js运算符的结合方向和及优先级</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>.、[ ]、( )</td>
<td>从左到右</td>
<td>高  ↑  |  |  |  |  |  |  |  |  |  |  | 低</td>
</tr>
<tr>
<td>++、–、-、！、new、typeof</td>
<td><mark>从右到左</mark></td>
<td></td>
</tr>
<tr>
<td>*、/、%</td>
<td>从左到右</td>
<td></td>
</tr>
<tr>
<td>+、-</td>
<td>从左到右</td>
<td></td>
</tr>
<tr>
<td>＜、＜=、＞、＞=、in、instanceof</td>
<td>从左到右</td>
<td></td>
</tr>
<tr>
<td><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td>从左到右</td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左到右</td>
<td></td>
</tr>
<tr>
<td>II</td>
<td>从左到右</td>
<td></td>
</tr>
<tr>
<td>?:</td>
<td><mark>从右到左</mark></td>
<td></td>
</tr>
<tr>
<td>=、*=、/=、％=、+=、-=、&amp;=、^=、!=</td>
<td><mark>从右到左</mark></td>
<td></td>
</tr>
<tr>
<td>,</td>
<td>从左到右</td>
<td>低</td>
</tr>
</tbody></table>
<hr>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script src&#x3D;&quot;scripts&#x2F;main.js&quot; defer&gt;&lt;&#x2F;script&gt;</code></pre></div>

<p><font color=red>值得注意的是引入外部js时不能使用自封闭标签</font></p>
<p>关于js中的reduce，reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p>
<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></pre></div>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>function(total,currentValue, index,arr)</em></td>
<td align="left">必需。用于执行每个数组元素的函数。 函数参数:参数描述<em>total</em>必需。<em>初始值</em>, 或者计算结束后的返回值。<em>currentValue</em>必需。当前元素<em>currentIndex</em>可选。当前元素的索引<em>arr</em>可选。当前元素所属的数组对象。</td>
</tr>
<tr>
<td align="left"><em>initialValue</em></td>
<td align="left">可选。传递给函数的初始值</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">🌰
[11,22,33,44,55].reduce((total, curval, index, arr) &#x3D;&gt; &#123;console.log(total + &#39;;&#39; + curval + &#39;;&#39; + index + &#39;;&#39; + JSON.stringify(arr))&#125;);
&#x2F;&#x2F; 输出
11;22;1;[11,22,33,44,55]
undefined;33;2;[11,22,33,44,55]
undefined;44;3;[11,22,33,44,55]
undefined;55;4;[11,22,33,44,55]
&#x2F;&#x2F;return 
undefined
🌰
[11,22,33,44,55].reduce((total, curval, index, arr) &#x3D;&gt; &#123;console.log(total + &#39;;&#39; + curval + &#39;;&#39; + index + &#39;;&#39; + JSON.stringify(arr));return total + curval;&#125;);
&#x2F;&#x2F; output
11;22;1;[11,22,33,44,55]
33;33;2;[11,22,33,44,55]
66;44;3;[11,22,33,44,55]
110;55;4;[11,22,33,44,55]
&#x2F;&#x2F; return
165
</code></pre></div>

<h2 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h2><h3 id="浏览器前置知识"><a href="#浏览器前置知识" class="headerlink" title="浏览器前置知识"></a>浏览器前置知识</h3><p>从URL到网页的过程</p>
<ol>
<li><p>浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</p>
</li>
<li><p>把请求回来的 HTML 代码经过解析，构建成 DOM 树；</p>
</li>
<li><p>计算 DOM 树上的 CSS 属性；</p>
</li>
<li><p>最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；</p>
</li>
<li><p>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</p>
</li>
<li><p>合成之后，再绘制到界面上。</p>
</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/63/4c/6391573a276c47a9a50ae0cbd2c5844c.jpg" srcset="/blog/img/loading.gif" lazyload></p>
<p>HTTP协议结构</p>
<img src="https://static001.geekbang.org/resource/image/3d/a1/3db5e0f362bc276b83c7564430ecb0a1.jpg" srcset="/blog/img/loading.gif" lazyload style="zoom:67%;" />

<p>HTTP的一些状态码</p>
<ul>
<li><p>1xx：临时回应，表示客户端请继续。</p>
</li>
<li><p>2xx：请求成功。</p>
<ul>
<li>200：请求成功</li>
</ul>
</li>
<li><p>3xx: 表示请求的目标有变化，希望客户端进一步处理。</p>
<ul>
<li>301&amp;302：永久性与临时性跳转。</li>
<li>304：跟客户端缓存没有更新。</li>
</ul>
</li>
<li><p>4xx：客户端请求错误。</p>
<ul>
<li>403：无权限。</li>
<li>404：表示请求的页面不存在。</li>
<li>418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）</li>
</ul>
</li>
<li><p>5xx：服务端请求错误。</p>
<ul>
<li>500：服务端错误。</li>
<li>503：服务端暂时性错误，可以一会再试。</li>
</ul>
</li>
</ul>
<p>HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用</p>
<ul>
<li><p>支持服务端推送</p>
<p>传统加载网页都是浏览器先获取网页资源，然后再解析网页时增量的请求其他资源，但服务器实际是知道网页资源有哪些，使用服务器可以主动的进行推送</p>
</li>
<li><p>TCP连接复用</p>
<p>使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题</p>
</li>
<li><p>…</p>
</li>
</ul>
<h3 id="浏览器合成位图"><a href="#浏览器合成位图" class="headerlink" title="浏览器合成位图"></a>浏览器合成位图</h3><p>渲染：</p>
<p>将搭建好的dom树和计算好的css属性添加到位图上的过程</p>
<p>合成：</p>
<p>基于一定算法优化位图的生成方式</p>
<blockquote>
<p>合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面</p>
</blockquote>
<p>合成策略的两个极端</p>
<ol>
<li>把所有dom元素创建一个合成后的位图，这样的话当一个dom元素变化时整个位图就失效需要重绘</li>
<li>每个dom元素单独形成一个位图，那么每次都要重新绘制所有的位图</li>
</ol>
<p>另外还有个热区的概念</p>
<blockquote>
<p> will-change 属性，可以由业务代码来提示浏览器的合成策略</p>
</blockquote>
<p>绘制：</p>
<p>主要属于操作系统范畴，在计算机图形计算范畴存在”脏矩形”的算法</p>
<h3 id="HTML节点"><a href="#HTML节点" class="headerlink" title="HTML节点"></a>HTML节点</h3><img src="https://static001.geekbang.org/resource/image/6e/f6/6e278e450d8cc7122da3616fd18b9cf6.png" srcset="/blog/img/loading.gif" lazyload style="zoom:70%;" />

<p> getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，<mark>而是一个能够动态更新的集合</mark></p>
<p>DOM的API大概分为以下几类</p>
<ul>
<li><p>节点：DOM 树形结构中的节点相关 API</p>
</li>
<li><p>事件：触发和监听事件相关 API</p>
</li>
<li><p>Range：操作文字范围相关 API</p>
</li>
<li><p>遍历：遍历 DOM 需要的 API</p>
<p>除了使用js进行遍历外还可以使用<code>NodeIterator</code> 和 <code>TreeWalker</code> 来遍历树</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; NodeIterator
var iterator &#x3D; document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);
var node;
while(node &#x3D; iterator.nextNode())
&#123;
    console.log(node);
&#125;</code></pre></div>

<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; TreeWalker
var walker &#x3D; document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false)
var node;
while(node &#x3D; walker.nextNode())
&#123;
    if(node.tagName &#x3D;&#x3D;&#x3D; &quot;p&quot;)
        node.nextSibling();
    console.log(node);
&#125;</code></pre></div></li>
</ul>
<h3 id="CSSOM获取一个元素的精确位置"><a href="#CSSOM获取一个元素的精确位置" class="headerlink" title="CSSOM获取一个元素的精确位置"></a>CSSOM获取一个元素的精确位置</h3><p>scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近</p>
<p><img src="https://static001.geekbang.org/resource/image/b6/10/b6c7281d86eb7214edf17069f95ae610.png" srcset="/blog/img/loading.gif" lazyload></p>
<p>绘制一个网页的所有盒轮廓到canvas上</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;  https:&#x2F;&#x2F;gist.github.com&#x2F;aimergenge&#x2F;2bcf41ac4c4d2586e48ccd5cec5c9768
void function () &#123;
  const canvas &#x3D; document.createElement(&#39;canvas&#39;)

  canvas.width &#x3D; document.documentElement.offsetWidth
  canvas.height &#x3D; document.documentElement.offsetHeight

  canvas.style.position &#x3D; &#39;absolute&#39;
  canvas.style.left &#x3D; &#39;0&#39;
  canvas.style.right &#x3D; &#39;0&#39;
  canvas.style.top &#x3D; &#39;0&#39;
  canvas.style.bottom &#x3D; &#39;0&#39;
  canvas.style.zIndex &#x3D; &#39;99999&#39;

  document.body.appendChild(canvas)

  const ctx &#x3D; canvas.getContext(&#39;2d&#39;)
  draw(ctx, getAllRects())

  function draw (ctx, rects) &#123;
    let i &#x3D; 0
    ctx.strokeStyle &#x3D; &#39;red&#39;
    window.requestAnimationFrame(_draw)

    function _draw () &#123;
      let &#123;x, y, width, height&#125; &#x3D; rects[i++]
      ctx.strokeRect(x, y, width, height)
      if (i &lt; rects.length) &#123;
          &#x2F;&#x2F; 和setTimeout类似，不过setTimeout需要指定时间，而window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘
        window.requestAnimationFrame(_draw)
      &#125; else &#123;
        console.log(&#39;%cDONE&#39;, &#39;background-color: green; color: white; padding: 0.3em 0.5em;&#39;)
      &#125;
    &#125;
  &#125;

  function getAllRects () &#123;
    const allElements &#x3D; document.querySelectorAll(&#39;*&#39;)
    const rects &#x3D; []
    const &#123;x: htmlX, y: htmlY&#125; &#x3D; document.documentElement.getBoundingClientRect()
    allElements.forEach(element &#x3D;&gt; &#123;
      const eachElRects &#x3D; Array.from(element.getClientRects()).filter(rect &#x3D;&gt; &#123;
        return rect.width || rect.height
      &#125;).map(rect &#x3D;&gt; &#123;
        return &#123;
          x: rect.x - htmlX,
          y: rect.y - htmlY,
          width: rect.width,
          height: rect.height
        &#125;
      &#125;)
      rects.push(...eachElRects)
    &#125;)
    return rects
  &#125;
&#125;()</code></pre></div>

<h3 id="捕捉过程和冒泡过程"><a href="#捕捉过程和冒泡过程" class="headerlink" title="捕捉过程和冒泡过程"></a>捕捉过程和冒泡过程</h3><p>在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。</p>
<p>addEventListener 有三个参数：</p>
<ul>
<li><p>事件名称；</p>
</li>
<li><p>事件处理函数；</p>
</li>
<li><p>捕获还是冒泡。</p>
</li>
</ul>
<p>事件处理函数不一定是函数，也可以是个 JavaScript 具有 handleEvent 方法的对象</p>
<div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 自定义事件
var evt &#x3D; new Event(&quot;look&quot;, &#123;&quot;bubbles&quot;:true, &quot;cancelable&quot;:false&#125;);
document.dispatchEvent(evt);</code></pre></div>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Events">Event MDN讲解</a></p>
<h3 id="浏览器API"><a href="#浏览器API" class="headerlink" title="浏览器API"></a>浏览器API</h3><p>多看标准和文档，这块比较杂，后期有机会二刷</p>
<h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p><img src="https://static001.geekbang.org/resource/image/6b/f2/6b5051c452af8c3db5fbb8ba6b9e34f2.jpg" srcset="/blog/img/loading.gif" lazyload alt="IMG"></p>
<p>Three.js 3D框架</p>
<p>GCanvas</p>
<p>拓展前端边界</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>计算机图形学</p>
<p>WebGL</p>
<p>TensorFlow</p>
<p>Weex 和 RN 虽然都叫 Hybird 但不太一样，前者适合大厂主要是嵌入 APP 中使用，后者更适合创业公司</p>
<p>最好的学习就是在项目中锻炼自己</p>
<p>专注 + 锻炼 + 利用周末</p>
<p>专注即工作时专注于工作，努力做好每次迭代，遇到难题迎难而上，工作时不开微信，勤用笔记安排日常工作并整理文档。</p>
<p>定期锻炼</p>
<p>牺牲周末和晚上时间</p>
<p>在职场上，除了提高技术能力外，提高表达能力也是突破瓶颈的主要点</p>
<blockquote>
<p>表达能力是形成自己的框架系统，有理有据并且逻辑清晰，而且能让外人听懂，大部分优秀的人都具备这样的能力。反观自己并没有这样的能力，所以我要努力提升这块，其中最重要的方法就是写作训练。</p>
</blockquote>
<p>通过写作搭建自身的知识框架，同时提高表达能力</p>
<p>正反馈机制和强健的体魄成为坚持的助力</p>
<p>resolve 在哪个宏任务中调用，对应的 then 里的微任务就属于哪个宏任务。宏任务没有从异步队列中取出，中间所碰到的所有微任务都属于这个宏任务</p>
<blockquote>
<p>框架不是赶时髦，追潮流，每个框架都有解决的问题，我觉得你该焦虑的不是你用的框架为什么这么老，而是你该知道这些新框架要解决什么问题，以及这些问题为什么在你的工作中不存在</p>
</blockquote>
<blockquote>
<p>在 promise 出现之前，javascript 并没有异步，有异步的是宿主环境</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/29086.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">全排序的生成方式(未完成)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/1.html">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/img-lazyload.js" ></script>
  



  
    
      <script  src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js" ></script>
      <script  src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js" ></script>
      
        <script  src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>
      
    
  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/blog/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>


</body>
</html>
