<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于[UIScreen mainScreen].bounds获取异常问题</title>
    <link href="/blog/25202.html"/>
    <url>/blog/25202.html</url>
    
    <content type="html"><![CDATA[<p>记录下开发中遇到的同一个设备在两个项目中[UIScreen mainScreen].bounds获取异常的问题原因</p><p>值得一提的是两个项目一个是比较稳定的上线主项目，另一个是临时搭的空白demo项目，最后发现问题出在<code>Launch Screen</code>上，XCode13新建项目时会存在默认的一个<code>LaunchScreen file</code>如下图</p><img src="data:image/png;base64,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SEACEpCABCQggc5IQEG/M94V+yQBCUhAAhKQgAQkIAEJSEACEpCABCQgAQlIQAISyBFQ0M8B8VACEpCABCQgAQlIQAISkIAEJCABCUhAAhKQgAQk0BkJKOh3xrtinyQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACOQIK+jkgHkpAAhKQgAQkIAEJSEACEpCABCQgAQlIQAISkIAEOiMBBf3OeFfskwQkIAEJSEACEpCABCQgAQlIQAISkIAEJCABCUggR0BBPwfEQwlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEpBAZyTQqzN2yj5JQAKVE7j11lvD008/HQvMOuus4fe//33lhc0Zjj322DBq1KhIYu211w7LLLOMVCQgAQlIQAISkIAEJCABCUhAAhKQgAQk0CkJKOh3wG0ZNmxY+NOf/hRbRohddNFFw9FHHx3mnnvuDuhNdU0ef/zx4eWXX46FFlhggXDQQQdVV4G5607gySefDEOGDIn18iy1JOi/8cYb4a9//WuxH4cddliYZ555isfdbef6668Pw4cPj5c911xztUrQl213e3q8XglIQAISkIAEJCABCUhAAhKQgAQk0L4EFPTbl3ds7c477yx6VJPwwgsvhFtuuSXsu+++HdCb6pp89dVXi31vaGiorrC5OwWBb7/9tngP6RADTFp9CMi2PhytRQISkIAEJCABCUhAAhKQgAQkIAEJSKA0gYkyhn4Kn1H6kkun1lKmdE0tp952221NMt1+++1N0kyQgAQkIAEJSEACEpCABCQgAQlIQAISkIAEJCABCSQCE52H/ksvvRS+/PLLMP3004f55psvXWez27feeit89NFHYcCAAWGppZZqNm9rT3722WfhmWeeaVLNxx9/HJ577rmw+OKLNznHYMPIkSNj+iSTTBL7OX78+PDhhx/Ga11wwQVD7969m5QjAe9r8mKTTTZZ6NWrV/jhhx/CO++8E6accspAzPW2MNok/Minn34a5p133ng/KmmHewGLhRdeOAwcOLBskVLXNWLEiMiwT58+MXzR5JNPXrY8J+BHe1NNNVXM379//2bzlzv5008/hXfffTc+QzPMMEMgbAv3KW+l7iN5uBfvv/9+GDx4cPw0N/Nh3Lhx4ZVXXon3e/bZZ4/3M99Oexx/8cUX4e233w5jxoyJ4XoGDRpUstlvvvmmmM7zlr220aNHB+4ZxnPJ85msHveXOv773/+GKaaYIv4tmHTSSVP1LW5//PHH+CzxXvF+lbqfLVZSIkOp6/r+++9jWzzvvCvZtj744IPIeaaZZorPaJZfvvpKn8NsOd5TQmjBhueJtvlbkwY4SS/3XqRnkf4T6qlfv37Zqkvu1+udK1m5iRKQgAQkIAEJSEACEpCABCQgAQlIoBsQmOgEfcR8DCEZa0nUf+2114p5EboRshCE28rwxE8CO+LdzDPPHO69997YHJ77pQT9U089NfzjH/+IeYiz/5e//CUccsghUQgmkf7+4he/CPvtt1+jWOhcz7LLLhvL8c/JJ58cnn/++XDVVVdFIZa02WabLay33nphjz324LDV9uabbwbi7BNGiPaTIVYS233HHXdMScXt0KFDwzHHHBP+85//hKwAPMccc4TVVlst/PnPf24kBOev6+9//3t44IEHAvwQNTGESNYp2HnnnYvtsIMIefbZZ4dLLrmkGDeddITShRZaKPztb38LtFuJff755/Fe3H///WHs2LHFIojTv/zlL8MJJ5zQSKTO30fi2O+1116BQZ5k9OGkk06Kwn5KY4sQTP5HH320GCJn6qmnDoceemg2W5vvExqK60rvWWqQ+3v44YeHNddcMyVFIZpFZpNdffXVYbHFFkuH4cwzzwwXXHBBPOY5vOuuu+J+a+4vFZxxxhnhjjvuiIMs6V3jniyyyCKR7YwzzhjbKfcP/C+//PLAgAOGqM+zm9a9KFeupfT8dfE88O7T1/T88PeA55kBSdanePjhh4vVMiBy2mmnNYnxX+1zSIWlnqd0D3meb7755tju0ksvHVkUO1HYYZCBd5z1PxDzMfgy8AGn1VdfPaalf+r5zqU63UpAAhKQgAQkIAEJSEACEpCABCQgge5KYKILuZMV8BH1EezLGV75SfgnDyJaW4r5tJENt7PqqquGX//61yRHI7Y+4ldzhpC62267FcV88jII8dBDD4Xdd989fPfdd2WLn3XWWVGcw6s6GZ7hCKCXXXZZSqp5i9CHYI/onBXzqfDrr7+OQvARRxzRqH48vXfYYYcobGbFfDLhuX7++eeHo446qlGZ/ME555wTbrrppqKYz3k8rBnAuO+++xpl32effaKQnBZBTScRfvHm3njjjePMgpRebosguu6664Z77rmnKMamvPBFFN1kk02K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SEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEmh7Agr6bc/YFiQgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJSEACrSagoN9qhFYgAQlIQAISkIAEJCABCUhAAhKQgAQkIAEJ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QAISkIAEJCABCUigOxLQQ7873nWvWQISkIAEJFAlAUR3hHji5VcaM7+5JlI9SdxvLq/nJNCRBDbbbLOw6qqrhqmmmqrqEFMd2e+Jse1Ro0YFZotgzPTRJCABCUhAAhKQgAQk0B0J6KHfHe+61ywBCUhAAhKokkDyyK+HmJ+api48+6m7LYywPpXa+PHjK83aJvlqab+egmY1rOoJoJZ2a73uWstxvaz10NJzWss9rOX66U+t5SibtWrr6Wz5s9dSar/a/paqwzQJSEACEpCABCQgAQl0NgJ66He2O2J/JCABCUhAAhKoisA999wTTj311LDEEkuE7bffPpx++unhmWeeCcOGDYtx3TfffPOw7bbbNplZ8OOPP8bY6I8//nh48sknA4LsAgssEFZYYYWwyy67VOSNfc0114TLLrssrL766mHvvfdu0u/tttsufPnll7F/88wzT6PzLHx7xx13hIcffjgMHz48zDvvvGH33XdvlCd/MHr06DBkyJBYhtBDAwYMCMstt1xsf7XVVstnb/b4tddei6zYEspk+umnDwsuuGDYcccdw5JLLtls2dacrKbdHXbYIS66e/LJJ4e33347nH/++XE7cODAwEK866yzTlhmmWWadKfWck0qKiQ88sgj4bjjjovPxoknntgoSy3PEGsO3H777fGZe/PNN8Pcc88dr4EFdxdbbLFG9XOQruWkk06K953FmV955ZUw2WSThUUXXTQcdNBBYfDgwU3KlUuohj918MyddtppgfeE/hImi2d5iy22iPzz7fAuXXTRRYG1IL7++usw22yzxQWF999//8B9y9t///vf8K9//SteGwtkc02sVbDJJpuEQYMGFbOvv/768T1JCRwzIPi73/0u7Lzzzik5cq2m/WJBdyQgAQlIQAISkIAEJNBFCCjod5EbZTclIAEJSEACHUmgnp75+etobd0I94ThQJBHHP/kk0/igrnE2H7nnXfCscceG7766qu4oG5qm7wssIs4iuF9TRoiOR9EyTPPPDP0798/FSm5RaynbeKslzLaZzFf4v9n7e677w577rlnbJN01hN48cUXw6677hrDu2TzZvcRRe+6666YRBgkBgJuuumm+EF03nDDDbPZy+5Tx7777ht++umnmKd3796RG+weeuihKPSvssoqZcvXeqLaduH36aefhnPOOSfceeedsVlYffbZ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QIAAgc4ItMH545q69quax+o1ZSKvV64qpV12XPs8kfdWNa/zOK55HH5EZ8ZvIAQIECBAgAABAgQIECBAoOsCAvpdP8PGR6BDAkv+9YlSdu/q0IgMhcAQAkuam+uWLmsezX/hy5vs+hUrmsfKJkDfBO6PWD5EhzYhQIAAAQIECBAgQIAAAQIERkVAQH9UzpTjJECglD+cQ4EAAQIECBAgQIAAAQIECBAgQIDA2AqooT+2p97ACRAgQIAAAQIECBAgQIAAAQIECBAgQGCUBAT0R+lsOVYCBAgQIECAAAECBAgQIECAAAECBAgQGFsBAf2xPfUGToAAAQIECBAgQIAAAQIECBAgQIAAAQKjJCCgP0pny7ESIECAAAECBAgQIECAAAECBAgQIECAwNgKCOiP7ak3cAIECBAgQIAAAQIECBAgQIAAAQIECBAYJQEB/VE6W46VAAECBAgQIECAAAECBAgQIECAAAECBMZWQEB/bE+9gRMgQIAAAQIECBAgQIAAAQIECBAgQIDAKAkI6I/S2XKsBAgQIECAAAECBAgQIECAAAECBAgQIDC2AgL6Y3vqDZwAAQIECBAgQIAAAQIECBAgQIAAAQIERklAQH+UzpZjJUCAAAECBAgQIECAAAECBAgQIECAAIGxFRDQH9tTb+AECBAgQIAAAQIECBAgQIAAAQIECBAgMEoCAvqjdLYcKwECBAgQIECAAAECBAgQIECAAAECBAiMrcDSxTryb7/9drEemuMiQIAAAQIECBAgQIAAAQIECBAgQIAAAQKHXECG/iEnt0MCBAgQIECAAAECBAgQIECAAAECBAgQIDB3gUWbob9u3bq5j8YWBAgQIECAAAECBAgQIECAAAECBAgQIECgowIy9Dt6Yg2LAAECBAgQIECAAAECBAgQIECAAAECBLolIKDfrfNpNAQIECBAgAABAgQIECBAgAABAgQIECDQUQEB/Y6eWMMiQIAAAQIECBAgQIAAAQIECBAgQIAAgW4JCOh363waDQECBAgQIECAAAECBAgQIECAAAECBAh0VEBAv6Mn1rAIECBAgAABAgQIECBAgAABAgQIECBAoFsCAvrdOp9GQ4AAAQIECBAgQIAAAQIECBAgQIAAAQIdFRDQ7+iJNSwCBAgQIECAAAECBAgQIECAAAECBAgQ6JaAgH63zqfRECBAgAABAgQIECBAgAABAgQIECBAgEBHBQT0O3piDYsAAQIECBAgQIAAAQIECBAgQIAAAQIEuiUgoN+t82k0BAgQIECAAAECBAgQIECAAAECBAgQINBRAQH9jp5YwyJAgAABAgQIECBAgAABAgQIECBAgACBbgkI6HfrfBoNAQIECBAgQIAAAQIECBAgQIAAAQIECHRUQEC/oyfWsAgQIECAAAECBAgQIECAAAECBAgQIECgWwIC+t06n0ZDgAABAgQIECBAgAABAgQIECBAgAABAh0VENDv6Ik1LAIECBAgQIAAAQIECBAgQIAAAQIECBDoloCAfrfOp9EQIECAAAECBAgQIECAAAECBAgQIECAQEcFBPQ7emINiwABAgQIECBAgAABAgQIECBAgAABAgS6JfBXQK5BuCmClHYAAAAASUVORK5CYII=" ><p>如果将demo项目的该项置空会发现mainScreen会变的更小，由此猜测mainScreen的获取和启动图有关，主项目中配置了启动图资源获取到的mainScreen是正常的</p><hr><p>修复方案：</p><ol><li>将demo项目中的LaunchScreen指向的LaunchScreen.storyBoard内的大小修改下，默认情况下像刘海屏的机子都会包括下巴和状态栏区域因此会偏大</li><li>给项目配置启动图资源，启动图资源的尺寸都是固定的，因此获取到的mainScreen也会是固定的</li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>chrome扩展开发简介</title>
    <link href="/blog/50126.html"/>
    <url>/blog/50126.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="了解Chrome插件"><a href="#了解Chrome插件" class="headerlink" title="了解Chrome插件"></a>了解Chrome插件</h2><p>chrome扩展插件可以为chrome浏览器增加额外的功能，它能对某个网页进行css注入或执行js方法，同时也可以实现单独的一个功能，同时它在进行网络请求时不会受到跨域的影响。所以它能实现什么主要依赖你的想象力</p><img width="240" alt="" src="https://user-images.githubusercontent.com/35450350/145677995-803e1d3b-58a2-456f-892e-9013ea74081a.png"><p>安装插件后在浏览器的输入框右侧将会出现你安装的插件图标</p><h2 id="如何安装插件"><a href="#如何安装插件" class="headerlink" title="如何安装插件"></a>如何安装插件</h2><p>目前安装插件的方式只有两种：</p><ol><li>在<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN">Chrome网上应用商店</a>来选择安装插件，这种安装的模式时基于<code>crx</code>包的，对扩展插件代码进行打包压缩后生成的<code>crx</code>格式文件可上传应用市场进行下载安装，但目前已经禁止直接加载现有外部的crx文件来安装插件</li><li>自己开发插件后在浏览器<a href="chrome://extensions/">扩展程序</a>设置中点击打开右侧的<code>开发者模式</code>，随后就可以点击<code>加载已解压的扩展程序</code>来安装插件，需要注意的是，这种模式下选择安装时选择的是扩展程序的源码工程文件夹，不支持外部crx直接安装</li></ol><img width="1278" alt="image" src="https://user-images.githubusercontent.com/35450350/145675534-481f9cb2-0534-4a0c-b847-5d4ac6b1a05c.png"><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><h2 id="开发目录结构"><a href="#开发目录结构" class="headerlink" title="开发目录结构"></a>开发目录结构</h2><img width="209" alt="image" src="https://user-images.githubusercontent.com/35450350/145678584-7b456b4c-eb14-4df7-9370-40d9f64718c8.png"><p><font color=blue>截图看起来有点多, 但其实最主要也是最首要的就是<code>manifset.json</code>文件</font></p><h2 id="manifset-json-插件的核心配置文件"><a href="#manifset-json-插件的核心配置文件" class="headerlink" title="manifset.json:插件的核心配置文件"></a><code>manifset.json</code>:插件的核心配置文件</h2><p>以下为文件内的配置内容简要说明，更多配置项和细节可查看<a href="https://developer.chrome.com/docs/extensions/mv3/manifest/">官方文档</a></p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;   &#x2F;&#x2F;必需  &#x2F;&#x2F; 指定了manifest所用规则的版本, 必需  &quot;manifest_version&quot;: 3,  &#x2F;&#x2F; 插件名称  &quot;name&quot;: &quot;My Extension&quot;,  &#x2F;&#x2F; 插件的版本，如“1.0.0”  &quot;version&quot;: &quot;versionString&quot;,  &#x2F;&#x2F; Recommended  &#x2F;&#x2F; 控制插件在chrome操作栏中显示的图标样式  &quot;action&quot;: &#123;        &quot;default_icon&quot;: &#123; &#x2F;&#x2F; optional            &quot;16&quot;: &quot;images&#x2F;icon16.png&quot;, &#x2F;&#x2F; optional            &quot;24&quot;: &quot;images&#x2F;icon24.png&quot;, &#x2F;&#x2F; optional            &quot;32&quot;: &quot;images&#x2F;icon32.png&quot; &#x2F;&#x2F; optional        &#125;,        &quot;default_title&quot;: &quot;Click Me&quot;, &#x2F;&#x2F; optional, shown in tooltip        &quot;default_popup&quot;: &quot;popup.html&quot; &#x2F;&#x2F; optional，popup为点击插件时出现的小窗页面   &#125;  &quot;default_locale&quot;: &quot;zh_CN&quot;, &#x2F;&#x2F; 若没有提供语言包且无需切换语言的话，可以删除此项，否则不提供语言包会报错  &quot;description&quot;: &quot;A plain text description&quot;, &#x2F;&#x2F; 一个简短的描述  &quot;icons&quot;: &#123;  &#x2F;&#x2F; 在chrome网上应用商店或者扩展管理中显示的图标    &quot;16&quot;: &quot;icon16.png&quot;,    &quot;48&quot;: &quot;icon48.png&quot;,    &quot;128&quot;: &quot;icon128.png&quot;   &#125;,  &#x2F;&#x2F; Optional  &quot;author&quot;: &quot;作者&quot;,  &quot;automation&quot;: ..., &#x2F;&#x2F; 官方文档中没解释这个是啥，看单词貌似和自动化有关  &quot;background&quot;: &#123; &#x2F;&#x2F; 在插件开发中background是一个很重要的概念，当然可能你要开发的功能用不到    &#x2F;&#x2F; Required    &quot;service_worker&quot;: &quot;background.js&quot;,  &#125;,  &quot;content_scripts&quot;: [    &#123;      &quot;matches&quot;: [&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;*&quot;],      &quot;run_at&quot;: &quot;document_start&quot;, &#x2F;&#x2F; &quot;document_idle&quot;网页空闲时,&quot;&quot;document_start&quot;和”document_end“为网页加载开始，加载结束      &quot;css&quot;: [&quot;css&#x2F;contentStyle.css&quot;], &#x2F;&#x2F; 对作用地址全局作用该css样式      &quot;js&quot;: [&quot;js&#x2F;contentScript.js&quot;]    &#125;  ],  &quot;devtools_page&quot;: &quot;devtools.html&quot; &#x2F;&#x2F; 和f12调试相关的内容，但目前没用到过，具体可以参考官方文档以获取更多细节&#125;</code></pre></div><ul><li>下图为官方的关于content_script, background以及devtools的关系图</li></ul><img src="https://wd.imgix.net/image/BrQidfK9jaQyIHwdw91aVpkPiib2/kcLMpTY6qtez03TVSqt4.png?auto=format&w=1044" style="width: 70%"><p>插件开发完成后，在chrome的扩展管理中<code>加载已经解压的扩展</code>选择项目根目录可以看到该插件</p><img width="417" alt="image" src="https://user-images.githubusercontent.com/35450350/145678817-b4e33ad7-5149-43b8-b4f4-c1f24a8b0780.png"><p>点击浏览器导航栏中的插件按钮后可以选择将该插件固定在导航栏</p><img width="240" alt="" src="https://user-images.githubusercontent.com/35450350/145677995-803e1d3b-58a2-456f-892e-9013ea74081a.png"><p><font size=2>图标不一样时因为manifset中这两项设的图片资源不同</font></p><h2 id="popup-html"><a href="#popup-html" class="headerlink" title="popup.html"></a>popup.html</h2><p>当我们点击浏览器导航栏中的插件时可以显示一个小的窗口页面，页面的样式对应着配置文件<code>manifest.json</code>文件中的<code>default_popup</code>项</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&quot;action&quot;: &#123;        &quot;default_icon&quot;: &#123; &#x2F;&#x2F; optional            &quot;16&quot;: &quot;images&#x2F;icon16.png&quot;, &#x2F;&#x2F; optional            &quot;24&quot;: &quot;images&#x2F;icon24.png&quot;, &#x2F;&#x2F; optional            &quot;32&quot;: &quot;images&#x2F;icon32.png&quot; &#x2F;&#x2F; optional        &#125;,        &quot;default_title&quot;: &quot;Click Me&quot;, &#x2F;&#x2F; optional, shown in tooltip        &quot;default_popup&quot;: &quot;popup.html&quot; &#x2F;&#x2F; optional，popup为点击插件时出现的小窗页面   &#125;</code></pre></div><p>比如对应popup.html的内容为</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;popup&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div style&#x3D;&quot;font-weight: bold; padding: 10px;&quot;&gt;Hello, World!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>展示效果</p><img width="265" alt="image" src="https://user-images.githubusercontent.com/35450350/145678084-40a9b8d4-c011-4f27-8385-b837dbd76d1b.png"><p><font color=blue>需要注意的是，该页面每次点击的时候都是重新生成的，取消时就会销毁，因此若在js中需要保留什么常驻变量或状态变量可定义在background.js中</font></p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;background&quot;: &#123; &#x2F;&#x2F; 在插件开发中background是一个很重要的概念，当然可能你要开发的功能用不到    &#x2F;&#x2F; Required    &quot;service_worker&quot;: &quot;background.js&quot;,    &#x2F;&#x2F; Optional    &quot;type&quot;: ...  &#125;</code></pre></div><p>background.js是在插件运行后在后台一直常驻的一个js，假设popup.html中想要实现一个计数器，但因为每次取消popup.html后该页面会被销毁，因此每次打开时计数会被清空，这个时候就可以在background.js中定义一个变量，在popup.html对应的js中直接使用，这样每次打开时计数变量就不会重新生成。</p><h2 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content_scripts"></a>content_scripts</h2><p>配置表中的”content_scripts”项目中可以配置针对部分地址或全部url地址注入的js和css</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;content_scripts&quot;: [    &#123;      &quot;matches&quot;: [&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;*&quot;],      &quot;run_at&quot;: &quot;document_end&quot;, &#x2F;&#x2F; &quot;document_idle&quot;网页空闲时,&quot;&quot;document_start&quot;和”document_end“为网页加载开始，加载结束      &quot;css&quot;: [&quot;css&#x2F;contentStyle.css&quot;], &#x2F;&#x2F; 对作用地址全局作用该css样式      &quot;js&quot;: [&quot;js&#x2F;contentScript.js&quot;]    &#125;  ],</code></pre></div><p>比如在<code>contentScript.js</code>中写一个alert，那么在<code>&quot;https://www.baidu.com/*&quot;</code>路径下记载开始都会显示一个alert，同时可以在css中基于这个页面中的元素进行样式覆盖，比如百度中<kbd>百度一下</kbd>按钮时蓝色的，通过<code>F12</code>可以看到这个按钮的类名是<code>s_btn</code>，那么在<code>contentStyle.css</code>文件中这样写</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">.s_btn &#123;    background-color: orange !important;&#125;</code></pre></div><p>展示效果</p><img width="808" alt="image" src="https://user-images.githubusercontent.com/35450350/145678303-1d4ef004-7e64-41f2-b06c-723ea43ea15e.png"><p>可以看到按钮的颜色已经变了，也运行了contentScript.js里面的alert</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上只是简单的整理了一些主要的使用内容，大部分的小功能用以上的就可以实现，但chrome扩展api中其实还有很多很牛逼的api可以实现很多很牛逼的功能，感兴趣的可以在<a href="https://developer.chrome.com/docs/extensions/">官方扩展开发指南</a>中查看api</p><h1 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h1><p>如果要上传扩展到Chrome应用商店的话</p><ol><li>点击进入<a href="https://chrome.google.com/webstore/devconsole/register?hl=zh-CN">https://chrome.google.com/webstore/devconsole/register?hl=zh-CN</a>并登陆谷歌账号，如果没有谷歌账号的话需要注册一个</li></ol><img width="1280" alt="image" src="https://user-images.githubusercontent.com/35450350/146175413-cb53249c-fbfc-4e00-a60a-cff095e453cb.png"><p>登陆成功后注册成为开发者需要勾选隐私协议并支付5美元的注册费，没有卡的话可以考虑万能的taobao</p><ol start="2"><li>购买成功后进入开发者工作台</li></ol><img width="1275" alt="image" src="https://user-images.githubusercontent.com/35450350/146176665-d40d1d39-447f-4e80-946b-f14bf3b76ef3.png"><p>点击上传新内容，然后选择已经压缩成zip的源码工程，之后会有一系列如：谷歌二重验证，截图等，按提示一步步操作即可</p><img width="1046" alt="image" src="https://user-images.githubusercontent.com/35450350/146184065-1e2644c9-32e2-4d3a-882c-6799a8237bce.png"><div style="border: 1px solid #ddd; border-left: 5px solid orange; padding: 5px">另外如果不能发布的理由提示需要提供一个联系的邮箱，这个设置在开发者工作台这边点击左上角里的账号中，而不是谷歌账号管理里面</div><p>最后再回到依赖的界面可以看到<code>提交审核</code>的按钮一键可以点了，如果还不能点击则可以点击旁边的<code>我为什么不能提交审核</code>以查看问题并处理</p><p><font color=dark>若是测试项目则到可以提交审核这步就可以结束了，没什么实际功能没必要提交审核上架，可以尝试开发一点有意思或者有实际意义的扩展项目，能用工具和代码解决的就不要再用手动去处理，懒才是第一生产力</font></p>]]></content>
    
    
    <categories>
      
      <category>H5</category>
      
      <category>chrome扩展开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-数据结构</title>
    <link href="/blog/37902.html"/>
    <url>/blog/37902.html</url>
    
    <content type="html"><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序初体验</title>
    <link href="/blog/27119.html"/>
    <url>/blog/27119.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html">微信官方快速入门文档</a></p><h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><ol><li><p>需要获取微信的开发者账号<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">注册账号</a></p></li><li><p>下载官方开发工具<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">下载</a></p></li></ol><h2 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h2><p>根据官方文档的建议，第一个项目不要使用云服务，appid为之前申请完账号后在开发设置查看的appId</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/first-program.2ee81a52.png" alt="img"></p><p>在微信开发项目中，主要由以下几类文件构成</p><ul><li>json文件：主要是微信原生部分的配置相关，如导航栏文字颜色之类</li><li>wxml文件：对标前端开发的HTML文件，但在使用元素上有点差异，但功能角色还是页面的骨架结构</li><li>wxss文件：对标前端开发的CSS文件</li><li>js文件：对标前端的js文件，语法上稍微有点差异</li></ul><p>工程结构：</p><ul><li>page文件夹：可以看到初始项目中，存放所以页面文件，而每个页面文件是由<code>.json</code>、<code>.wxml</code>、<code>.wxss</code>、<code>.js</code>文件组成的文件夹</li><li>utils文件夹：内部包含js文件，主要是写公共方法</li><li>根目录下其他文件：<ul><li><code>app.js</code> ：application级别的js文件编写，page文件夹下的js主要是针对此页面的js</li><li><code>app.json</code>：全局的配置，一般用来写默认全局默认配置</li><li><code>app.wss</code>: 全局默认样式</li><li><code>project.config.json</code>：针对编译器的配置相关文件，主要是为换设备后同步配置使用</li></ul></li></ul><h2 id="快速Demo"><a href="#快速Demo" class="headerlink" title="快速Demo"></a>快速Demo</h2><p>剩下的细节部分可以忽略，直接开发吧，可以遇到问题再看文档</p>]]></content>
    
    
    <categories>
      
      <category>H5</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ios广播</title>
    <link href="/blog/60709.html"/>
    <url>/blog/60709.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>引用参考</p><p>作者：爱吃鱼的小灰<br>链接：<a href="https://www.jianshu.com/p/64501bbfc881">https://www.jianshu.com/p/64501bbfc881</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>同步：消息发送需要等待观察者处理完成消息后再继续执行；</p><p>单向：发送者只发送消息，接收者不需要回复消息；</p><p>线程安全：消息发送及接收都是在同一个线性完成，不需要处理线程同步问题</p></blockquote><blockquote><p>每一个程序都有一个自己的通知中心，即NSNotificationCenter对象。该对象采用单例设计模式，采用defaultCenter方法就可以获得唯一的NSNotificationCenter对象。</p></blockquote><h3 id="观察者注册通知"><a href="#观察者注册通知" class="headerlink" title="观察者注册通知"></a>观察者注册通知</h3><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c"> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(logOutSuccess:)  name:@&quot;isLogOutSuccess&quot; object:nil];&#x2F;&#x2F; notificationObserver 观察者 : self&#x2F;&#x2F; notificationSelector 处理消息的方法名: logOutSuccess:&#x2F;&#x2F; notificationName 消息通知的名字: isLogOutSuccess&#x2F;&#x2F; notificationSender 消息发送者 : 表示接收哪个发送者的通知，如果第四个参数为nil,接收所有发送者的通知</code></pre></div><h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;isLogOutSuccess&quot; object:msg];&#x2F;&#x2F; 这个比第一个多了个参数就是userInfo(参数类型是字典)[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;isLogOutSuccess&quot; object: msg userInfo:[NSDictionary dictionaryWithObject:@&quot;value&quot; forKey:@&quot;key&quot;]];&#x2F;&#x2F; 发送广播携带数据有两种方式一种是通过object携带，一种是通过userInfo携带</code></pre></div><blockquote><p>如将上面的代码中 name改为nil,那么观察者将接收到object对象的所有消息，但是确定不了接收这些消息的顺序。如果指指定一个通知名称，观察者将收到它每次发出 的通知。例如，上面的代码中object为nil，那么客户对象（self）将收到任何对象发出NSWindowDidBecomeMainNotification通知。如果既没有指定指定object，也没有指定name，那么该观察者将收到所有对象的所有消息。</p><p><font color=red>待验证</font></p></blockquote><h3 id="处理方法中获取对应参数"><a href="#处理方法中获取对应参数" class="headerlink" title="处理方法中获取对应参数"></a>处理方法中获取对应参数</h3><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; 在注册通知的控制器中写入该方法  -(void) isLogOutSuccess:(NSNotification*)notification&#123;     NSString *nameString &#x3D; [notification name];     NSString *objectString &#x3D; [notification object];     NSDictionary *dictionary &#x3D; [notification userInfo];&#125;</code></pre></div><h3 id="注销广播监听"><a href="#注销广播监听" class="headerlink" title="注销广播监听"></a>注销广播监听</h3><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; 在监听类中注销单个广播监听[[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;isLogOutSuccess&quot; object:nil];&#x2F;&#x2F; 在监听类中注销全部的广播[[NSNotificationCenter defaultCenter] removeObserver:self];</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS深度链接 - 外部拉起App</title>
    <link href="/blog/19229.html"/>
    <url>/blog/19229.html</url>
    
    <content type="html"><![CDATA[<p>iOS的拉起APP的方式有两种：<code>URL Scheme</code>和<code>Universal Links</code>，后者是在WWDC2015退出的支持<code>ios9+</code></p><h2 id="URL-Scheme方式"><a href="#URL-Scheme方式" class="headerlink" title="URL Scheme方式"></a>URL Scheme方式</h2><p>目标APP可以配置自己的<code>URL Scheme</code>然后可以浏览器或其他APP可以基于配置的<code>URL Scheme</code>来拉起目标APP</p><p><code>URL</code>地址格式排列为：<code>scheme://host:port/path</code>，其中scheme为目标APP定义</p><h3 id="目标APP配置URL-Scheme"><a href="#目标APP配置URL-Scheme" class="headerlink" title="目标APP配置URL Scheme"></a>目标APP配置<code>URL Scheme</code></h3><p>配置的方法有两种，不同最后的效果都是一样的</p><ul><li>在<code>Info.plist</code>中进行配置</li></ul><img width="856" alt="image" src="https://user-images.githubusercontent.com/35450350/134499204-ffdc7f98-2738-4e23-99b1-e45a9d4069f4.png"><ol><li>在info.plist文件中添加<code>URL types</code></li><li>在item中添加一个<code>URL Schemes</code></li><li>填写<code>URL Schemes</code>和<code>URL identifier</code>， 其中scheme用作唤起app使用，identifier</li></ol><ul><li>也可以在对应target的info中进行填写</li></ul><img width="991" alt="image" src="https://user-images.githubusercontent.com/35450350/134500422-1f04e728-2b59-4fcd-9aaf-7a1327b6d9a3.png"><p>两者没什么区别只是位置不同</p><div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>在URL Types配置的Icon作用不是很明确一般不配置，Role的话对应iOS来说没什么作用主要是MACOSX使用，</div><p>至此目标app的sheme已经配置完成，不过还有几点需要说明</p><ul><li>关于多个app有同样的sheme时，若其中有原生APP则系统原生APP优先，否则可能根据包名排序来</li><li>除了对应的app外，其他app不能使用注册的bundle id作为sheme</li></ul><h3 id="目标app被唤起时的生命周期"><a href="#目标app被唤起时的生命周期" class="headerlink" title="目标app被唤起时的生命周期"></a>目标app被唤起时的生命周期</h3><p><font color=blue>首先关于生命周期主要分以下两个情况</font></p><ol><li><p><strong>当URL到达时，如果你的应用没在正在运行，则会被启动并且移到前台运行以打开URL</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">application:didFinishLaunchingWithOptionsapplication:openURL:sourceApplicationapplicationDidBecomeActive</code></pre></div></li><li><p>当URL到达时，如果你的应用正在background运行或被suspended，它将会被移到前台以打开URL</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">applicationWillEnterForegroundapplication:openURL:sourceApplication:applicationDidBecomeActive</code></pre></div></li></ol><p><font color=blue>openURL对应的回调方法</font></p><ul><li>iOS 2-9</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (BOOL)application:(UIApplication *)application             openURL:(NSURL *)url   sourceApplication:(NSString *)sourceApplication          annotation:(id)annotation &#123;             &#x2F;&#x2F; 处理业务逻辑             return YES;         &#125;</code></pre></div><ul><li>iOS 9+</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (BOOL)application:(UIApplication *)app             openURL:(NSURL *)url             options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey, id&gt; *)options &#123;            &#x2F;&#x2F; 处理业务逻辑            return YES;            &#125;</code></pre></div><blockquote><p>关于回调方法中的return type，开发者文档上失这么说的</p><p><em><code>YES</code> if the delegate successfully handled the request or <code>NO</code> if the attempt to open the URL resource failed.</em></p><p>都是实际return NO的话并没有什么效果，这个attempt就很有灵性</p></blockquote><h3 id="使用URL-Scheme唤起APP"><a href="#使用URL-Scheme唤起APP" class="headerlink" title="使用URL Scheme唤起APP"></a>使用<code>URL Scheme</code>唤起APP</h3><p><strong>在原生中</strong></p><ul><li>ios 9+</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;demoapp:&#x2F;&#x2F;name&#x3D;user&amp;val&#x3D;123&quot;] options:@&#123;&#125; completionHandler:^(BOOL success) &#123;            NSLog(@&quot;唤起:%@&quot;, success ? @&quot;成功&quot; : @&quot;失败&quot;);        &#125;];</code></pre></div><ul><li>iOS 2-9</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;demoapp:&#x2F;&#x2F;name&#x3D;user&amp;val&#x3D;123&quot;] ];</code></pre></div><p>在<code>://</code>后被传递的参数在目标APP的<code>openurl</code>对应生命周期回调中可以通过<code>[url host]</code>或<code>[url query]</code>的方式查到</p><p><strong>在浏览器中</strong></p><p>直接访问<code>@&quot;demoapp://name=user&amp;val=123&quot;</code>这个地址即可</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>使用<code>URL Scheme</code>的方法最大的优点就是方便，但也有对应的缺陷</p><ol><li>写在info.plist文件中的Scheme可能会被一些反编译手段获取到。</li><li>URL Scheme可能会被劫持调来安全隐患，比如某些app通过巧妙的设置自己包名，然后再配置和其他app系统的sheme，那么通过这个sheme唤起app时就会唤起某些app而非预想的特定APP。</li></ol><blockquote><p>1.对应也有一些处理，比如自己调用自己的scheme，来证明自己是否被拦截</p><p>2.利用 MobileCoreServices 服务中的 applicationsAvailableForHandlingURLScheme() 来查看所有注册了该 URL Schemes 的应用和处理顺序，从而检测自己、或者别人的 URL Scheme 是否被劫持。</p></blockquote><h2 id="Universal-Link方式"><a href="#Universal-Link方式" class="headerlink" title="Universal Link方式"></a>Universal Link方式</h2><h3 id="目标APP配置"><a href="#目标APP配置" class="headerlink" title="目标APP配置"></a>目标APP配置</h3><p><mark>配置bundleId, 必须为付费Apple developer， 否则没法测试</mark></p><img width="769" alt="image" src="https://user-images.githubusercontent.com/35450350/134509831-165e5f6e-0e3b-4d78-8ac3-a363ff14b550.png"><p>Xcode 添加配置，添加支持<code>Associated Domains</code>，也可以在对应账号的开发者网站中选择该app的identify后勾选特定能力。</p><h3 id="放置配置文件"><a href="#放置配置文件" class="headerlink" title="放置配置文件"></a>放置配置文件</h3><p>苹果会根据我们在下一步配置的路径来请求我们放置的配置文件，配置文件的格式如下</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;applinks&quot;: &#123;        &quot;apps&quot;: [],        &quot;details&quot;: [            &#123;                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,                &quot;paths&quot;: [ &quot;&#x2F;wwdc&#x2F;news&#x2F;&quot;, &quot;&#x2F;videos&#x2F;wwdc&#x2F;2015&#x2F;*&quot;]            &#125;,            &#123;                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,                &quot;paths&quot;: [ &quot;*&quot; ]            &#125;        ]    &#125;&#125;</code></pre></div><blockquote><p><code>appID</code>：组成方式是<code>TeamID.BundleID</code>。如上面的<code>9JA89QQLNQ</code>就是<code>teamId</code>。登陆开发者中心，在<code>Account -&gt; Membership</code>里面可以找到<code>Team ID</code> <code>paths</code>：设定你的<code>app</code>支持的路径列表，只有这些指定路径的链接，才能被<code>app</code>所处理。<code>*</code>的写法代表了可识别域名下所有链接</p><p>作者：72行代码<br>链接：<a href="https://juejin.cn/post/6844903988526055437">https://juejin.cn/post/6844903988526055437</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>将文件放置到服务器上给苹果下载，其中有几点注意事项</p><ul><li>文件名必须是<code>apple-app-site-association</code>,没有后缀，在shell上可以直接使用touch命令来创建</li><li>文件必须是在你域名的<mark>根目录</mark>或<mark>.well-konw目录</mark>下，苹果会去下载文件以获取该app的universal link配置</li><li>需要是https</li></ul><p>将文件放上去后可以访问<a href="https://search.developer.apple.com/appsearch-validation-tool/">官方测试网站</a>，尝试是否能成功下载，或者自己在浏览器中范围<code>https://你的域名/apple-app-site-association</code>查看能否下载</p><blockquote><p>关于域名后能否带端口网上资料大多都是说不能带，但目前很少会支持不带端口请求，目前亲测有几种情况，带端口后在官方网站测试通过；另外一个带不带都失败的在实际使用中也ok，所以可以接下去再看</p></blockquote><h3 id="添加app-domains路径"><a href="#添加app-domains路径" class="headerlink" title="添加app domains路径"></a>添加app domains路径</h3><p><img src="https://upload-images.jianshu.io/upload_images/2452209-70910af8cc40c5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="img"></p><blockquote><p>界面可能有所不同， 不过主要是在<code>Associated Domains</code>位置配置</p></blockquote><p>此处配置的路径即是上一步中放配置文件的域名，对应结构为<code>applinks:域名</code></p><p>配置完后就可以在手机上测试使用<code>https://你的域名/之前配的对应的path路径/</code>来访问看看能不能拉起app，注意配完后要重新打包才能起效</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++常用的算法库(algorithm)</title>
    <link href="/blog/63568.html"/>
    <url>/blog/63568.html</url>
    
    <content type="html"><![CDATA[<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><blockquote><p>C++的算法库algorithm中封装了很多好用的方法，诸如查找最值元素、序列逆转等，在实际code的时候可以提供有力的支持</p></blockquote><p>在使用前需要引入<code>#include&lt;algorithm.h&gt;</code>头文件</p><h2 id="寻找最值"><a href="#寻找最值" class="headerlink" title="寻找最值"></a>寻找最值</h2><h3 id="寻找容器内的最值"><a href="#寻找容器内的最值" class="headerlink" title="寻找容器内的最值"></a>寻找容器内的最值</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt;v&#123;0,1,2,3,4,1,2,-1&#125;;cout&lt;&lt;*min_element(v.begin(),v.end())&lt;&lt;endl;&#x2F;&#x2F;最小元素cout&lt;&lt;*max_element(v.begin(),v.end())&lt;&lt;endl;&#x2F;&#x2F;最大元素</code></pre></div><h3 id="使用自定义比较函数来寻找最值"><a href="#使用自定义比较函数来寻找最值" class="headerlink" title="使用自定义比较函数来寻找最值"></a>使用自定义比较函数来寻找最值</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class MyClass &#123;    int idc;    int value;&#125;bool mycompare (const MyClass&amp; a, const MyClass&amp; b) &#123;    return a.value &gt; b.value;&#125;&#x2F;&#x2F; 传入自定义compare方法min_element(v.begin(),v.end(), mycompare);max_element(v.begin(),v.end(), mycompare);&#x2F;&#x2F; 使用自定义比较器后方法名前面的max和min</code></pre></div><h2 id="元素查找-amp-个数"><a href="#元素查找-amp-个数" class="headerlink" title="元素查找&amp;个数"></a>元素查找&amp;个数</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">find();count();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 容器内元素查找find(v.begin(), v.end(), val);&#x2F;&#x2F; 返回引用第一个匹配元素的迭代器，找不到返回迭代器endcount(beg, end, val); &#x2F;&#x2F; 返回容器中值为val的个数    find_first_of(beg1, end1, beg2, end2); &#x2F;&#x2F;第一个范围中查找与第二个范围中任意元素相等的第一个（或最后一个）元素。</code></pre></div><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">sort</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">sort(beg, end); &#x2F;&#x2F; 默认排序为升序(从小到大)&#x2F;&#x2F; 使用之定义比较器，一般适用于自定义类或结构体bool mycompare (const MyClass&amp; a, const MyClass&amp; b) &#123;    return a.value - b.value;&#125;sort(beg, end, mycompare);&#x2F;&#x2F; 简单的希望排序为降序时vector&lt;int&gt;v&#123;1,2,3,0,8&#125;;bool descpare(int a, int b) &#123;    return a &gt; b;&#125;sort(v.begin(), v.end(), descpare);</code></pre></div><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h4 id="unqiue"><a href="#unqiue" class="headerlink" title="unqiue"></a>unqiue</h4><p>在STL中unique函数是一个去重函数，<mark> unique的功能是去除<font color=red>相邻的重复元素</font>&gt;(只保留一个),其实它并不真正把重复的元素删除</mark>，是把重复的元素移到后面去了，方法返回去重后最后一个元素的地址</p><p>因此对于序列<code>&#123;1,1,3,1,5&#125;</code>使用后的序列为<code>&#123;1,2,1,5,5&#125;</code></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 若要对全数组进行去重则可以先排序后删除sort(v.begin(), v.end()); vector&lt;string&gt;::iterator end_unique &#x3D;  unique(v.begin(), v.end()); v.erase(end_unique, v.end());&#x2F;&#x2F; 另外也可以使用set来回转一次去除重复数据</code></pre></div><h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p>使用<code>reverse</code>可以对容器中的元素进行翻转</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 翻转stringstring s &#x3D; &quot;abc&quot;;reverse(s.begin(), s.end());cout&lt;&lt;s; &#x2F;&#x2F; ”cba“&#x2F;&#x2F; 翻转vectorvector&lt;int&gt;v&#123;1,2,3,4,5&#125;;reverse(v.begin(), v.end());v; &#x2F;&#x2F; &#123;5,4,3,2,1&#125;</code></pre></div><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>数组类的使用中有时会设置交换两个位置的值，可以使用<code>swap</code></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt;v&#123;1,2,3,4,5&#125;;swap(v[1], v[2]);&#x2F;&#x2F; &#123;1,3,2,4,5&#125;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(uni.begin(), uni.end(), [](int x) &#123;cout &lt;&lt; x &lt;&lt; endl; &#125;);  vector&lt;char&gt; str&#123; &#39;a&#39;,&#39;s&#39;,&#39;d&#39;,&#39;g&#39;,&#39;v&#39;&#125;;&#x2F;&#x2F; 遍历每一个元素，进行处理其中的数据transform(str.begin(), str.end(), str.begin(), ::toupper);    </code></pre></div><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; uni(v.size() + b.size());sort(v.begin(), v.end());sort(b.begin(), b.end());&#x2F;&#x2F; 并集set_union(v.begin(), v.end(), b.begin(), b.end(), uni.begin()); &#x2F;&#x2F; 交集  set_intersection(v.begin(), v.end(), b.begin(), b.end(), uni.begin()); &#x2F;&#x2F; 差集set_difference(v.begin(), v.end(), b.begin(), b.end(), uni.begin());</code></pre></div><h2 id="在序列中寻找第一个大于等于某值而小于下一个值"><a href="#在序列中寻找第一个大于等于某值而小于下一个值" class="headerlink" title="在序列中寻找第一个大于等于某值而小于下一个值"></a>在序列中寻找第一个大于等于某值而小于下一个值</h2><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 序列需要预先有序&#x2F;&#x2F; 查找 [first, last) 区域内是否包含 valbinary_search(v.begin(), v.end(), val);&#x2F;&#x2F; 从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。lower_bound(v.begin(), v.end(), num);&#x2F;&#x2F; 从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound(v.begin(), v.end(), num);</code></pre></div><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int sum &#x3D; accumulate(vec.begin() , vec.end() , 42); &#x2F;&#x2F; 初始值为42 + [begin, end)的和&#x2F;&#x2F; 算不上特别好用但免除了写for的麻烦</code></pre></div><h2 id="移除序列中的所有x"><a href="#移除序列中的所有x" class="headerlink" title="移除序列中的所有x"></a>移除序列中的所有x</h2><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; remove 移动了区间中的元素。其结果是，“需要被删除”的元素被移到了区间的尾部。它返回一个迭代器，指向第一个“需要被删除”的元素。remove(v.begin(), v.end(), 1);</code></pre></div><h2 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h2><h3 id="string和number装换-stringstream"><a href="#string和number装换-stringstream" class="headerlink" title="string和number装换(stringstream)"></a>string和number装换(stringstream)</h3><p>需要包括头文件<code>#include&lt;sstream&gt;</code></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;sstream&gt;&#x2F;&#x2F; 数字转stringstringstream ss;string str;ss&lt;&lt;123;ss&gt;&gt;str;cout&lt;&lt;str; &#x2F;&#x2F; &quot;123&quot;&#x2F;&#x2F; string转数字stringstream ss;string str &#x3D; &quot;123&quot;; &#x2F;&#x2F; 若字符串是&quot;123.3&quot;这种浮点数字符串的话x应该为float，否则用int来接的话会变为123int x;ss&lt;&lt;str;ss&gt;&gt;x;cout&lt;&lt;x; &#x2F;&#x2F; 123</code></pre></div><h3 id="使用文件进行输入输出"><a href="#使用文件进行输入输出" class="headerlink" title="使用文件进行输入输出"></a>使用文件进行输入输出</h3><p>有时候输入用例的值很多，这个时候就使用文件作为输入流会方便很多</p><p>需要包括头文件<code>#include&lt;fstream&gt;</code></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 使用外部文件作为cin输入#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;using namespace std;int main() &#123;    ifstream cin(&quot;aaa.txt&quot;); &#x2F;&#x2F; 和代码文件同目录    int a, b, c, d;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;    cout&lt;&lt;&quot;a&#x3D;&quot;&lt;&lt;a&lt;&lt;&quot;,b&#x3D;&quot;&lt;&lt;b&lt;&lt;&quot;,c&#x3D;&quot;&lt;&lt;c&lt;&lt;&quot;,d&#x3D;&quot;&lt;&lt;d&lt;&lt;endl;    &#x2F;&#x2F; 若想cout输出到文件则使用ofstream cout(&quot;aaa.txt&quot;); 需要注意文件写入为覆盖非追加    return 0;&#125;</code></pre></div><h4 id="指定范围内的均匀随机数"><a href="#指定范围内的均匀随机数" class="headerlink" title="指定范围内的均匀随机数"></a>指定范围内的均匀随机数</h4><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; [a,b)的随机整数(rand() % (b-a))+ a;&#x2F;&#x2F; [a,b]的随机整数(rand() % (b-a+1))+ a;&#x2F;&#x2F; (a,b]的随机整数(rand() % (b-a))+ a + 1;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法前置C++容器篇</title>
    <link href="/blog/5076.html"/>
    <url>/blog/5076.html</url>
    
    <content type="html"><![CDATA[<div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>在使用C++进行算法编写时，至少应当熟悉各个容器的使用，这样就不会在使用一种数据结构时总需要去查询容器的基础API方法</div><h1 id="容器篇"><a href="#容器篇" class="headerlink" title="容器篇"></a>容器篇</h1><blockquote><p>在使用各个容器前都需要引入各种的头文件，或者可以使用C++的万能头文件<code>#include&lt;bits/stdc++.h&gt;</code>避免麻烦</p></blockquote><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>vector头文件为<code>#include&lt;vector&gt;</code></p><h3 id="常用初始化方法"><a href="#常用初始化方法" class="headerlink" title="常用初始化方法"></a>常用初始化方法</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt;v; &#x2F;&#x2F; 创建空vectorvector&lt;int&gt;v(10, 1);&#x2F;&#x2F; 初始化10个1vector&lt;int&gt;v&#123;-1,-1&#125;;&#x2F;&#x2F; 以-1，-1初始化元素int a[] &#x3D; &#123;-1, -1&#125;;vector&lt;int&gt;v(a, a+2);&#x2F;&#x2F; 以数组初始化vector,参数发布为初始化范围的起止vector&lt;int&gt;v(vec.begin(), vec.end();&#x2F;&#x2F; 以另一个vector初始化一个vector&#x2F;&#x2F; 以上v为生成的vector变量，同时进行了一些初始化赋值，对应的也可以使用以下声明方式进行声明及初始化vector&lt;int&gt;v &#x3D; vector&lt;int&gt;(10, 1);&#x2F;&#x2F; 初始化10个1</code></pre></div><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">v.push_back(1);&#x2F;&#x2F; 末尾追加元素v.insert(v.begin(), 1);&#x2F;&#x2F; 在begin前插入新元素1，也就是首位插入1&#x2F;&#x2F; insert相关APIinsert(pos,elem);&#x2F;&#x2F; 在迭代器pos位置前插入elem元素insert(pos,n,elem);&#x2F;&#x2F; 在迭代器pos位置前插入n个elem元素insert(pos,first,last);&#x2F;&#x2F; 在迭代器pos位置前插入其他容器(不限于vector)[first, last)的所有元素insert(pos,initlist);&#x2F;&#x2F; 在迭代器pos指定位置前，插入初始化列表&#123;1,2,3,4&#125;&#x2F;&#x2F; 例，v.insert(v.end(), &#123; 10,11 &#125;);</code></pre></div><p>在c++11中添加了emplace相关的api，经常可以在leetcode上看到题解使用的是emplace_back()追加元素而不是push_back();</p><p>关于这两者在底层实现上有所区别，大概就是push体系在底层会先产生一个拷贝的中间临时变量值，而emplace体系则是直接在元素末尾创建这个值</p><blockquote><p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p><a href="http://c.biancheng.net/view/6826.html">http://c.biancheng.net/view/6826.html</a></p></blockquote><p>简单来说就是push_back的底层实现比emplace_back更繁琐，<font color=dark>emplace的执行效率更高，建议使用emplace体系(低版本c++不兼容，若要考虑兼容性还是用push)</font></p><p><strong>C++11中添加的emplace体系</strong></p><p>和push_back, push_front, insert对应的有emplace_back, emplace_front, emplace</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">v.emplace_back(1);&#x2F;&#x2F; 末尾追加元素v.emplace_front(2);&#x2F;&#x2F; 首位追加元素&#x2F;&#x2F; 和insert不同，emplace每次只能插入一个元素而不是多个v.emplace(v.begin(), 1);&#x2F;&#x2F; 首位插入1</code></pre></div><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pop_back(); &#x2F;&#x2F;删除最后一个元素erase(pos);&#x2F;&#x2F; 删除迭代器pos位置的元素erase(begin, end);&#x2F;&#x2F; 删除[begin, end) 迭代器区域内的内容clear();&#x2F;&#x2F; 删除所以元素</code></pre></div><p>另外还有在算法库&lt;algorithm.h&gt;中的remove()方法可以删除容器在的元素</p><blockquote><p>STL中remove()只是将待删除元素之后的元素移动到vector的前端，而不是删除。若要真正移除，需要搭配使用erase()。</p></blockquote><p>==使用场景==</p><div style='border-left: 5px solid #FFA500; padding: 10px;background: #F5F5F5; color: #555'>因为在多元素遍历情况下删除时，使用erase会产生迭代器野指针问题，使用remove后会返回移动到末尾的要删除的元素迭代器起始位置，因此可以使用一些代码，配合删除vector中的多个元素</div><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;algorithm&gt;vector&lt;int&gt;::iterator iter &#x3D; remove(v.begin(), v.end(), 3);v.erase(iter, v.end());</code></pre></div><h3 id="改-amp-查"><a href="#改-amp-查" class="headerlink" title="改 &amp; 查"></a>改 &amp; 查</h3><p>修改容器内容有几种方法，利用删除和添加实现修改，在遍历中修改，直接基于下标修改</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">v[0] &#x3D; 1;&#x2F;&#x2F; 修改下标为1的内容&#x2F;&#x2F; 迭代器修改vector&lt;int&gt;::iterator it &#x3D; find(v.begin(), v.end(), 6);if(it !&#x3D; v.end()) &#123;    *it &#x3D; 7;&#125;v.back(); &#x2F;&#x2F; 放回v的最后一个元素v.front(); &#x2F;&#x2F;返回v的第一个元素&#x2F;&#x2F; 容器大小v.size();</code></pre></div><p>vector本身没有查找相关的api，需要借用算法库<code>algorithm.h</code>中的find方法</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;::iterator it &#x3D; find(v.begin(), v.end(), 6);&#x2F;&#x2F; 若it &#x3D;&#x3D; v.end(); 表示找不到该元素</code></pre></div><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 基于下标遍历for (int i &#x3D; 0, len &#x3D; v.size(); i &lt; len; i++) &#123;    cout&lt;&lt;v[i]&lt;&lt;endl;&#125;&#x2F;&#x2F; 基于迭代器遍历vector&lt;int&gt;::iterator it; &#x2F;&#x2F; 迭代器的声明for(it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;    cout&lt;&lt;*it&lt;&lt;endl;&#125;&#x2F;&#x2F; for infor (int x : v) &#123;    cout&lt;&lt;x&lt;&lt;endl;&#125;</code></pre></div><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><span id="queue">Queue</span></h2><p>对应头文件为<code>#include&lt;queue&gt;</code></p><p>queue表示的是队列结构，具有先进先出的特性</p><h3 id="常用初始化方法-1"><a href="#常用初始化方法-1" class="headerlink" title="常用初始化方法"></a>常用初始化方法</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;queue&gt;queue&lt;int&gt; q; &#x2F;&#x2F;初始化一个空队列queue&lt;int&gt; qq &#x3D; queue&lt;int&gt;();&#x2F;&#x2F;初始化一个空队列queue&lt;int&gt;copy_q &#123;q&#125;; &#x2F;&#x2F;拷贝容器q生成copy_q队列</code></pre></div><h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 队列末尾添加元素q.push();q.emplace();</code></pre></div><h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 从队首删除一个元素,需要注意容器目前是否还有元素q.pop();</code></pre></div><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 若出现需要随机访问队列中间元素时需要考虑当前场景是否应该使用vectorq.back(); &#x2F;&#x2F;队尾元素q.front(); &#x2F;&#x2F;队头元素&#x2F;&#x2F; 容器大小q.size();&#x2F;&#x2F; 容器是否为空q.empty(); &#x2F;&#x2F; 返回bool型标识是否为空</code></pre></div><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 在遍历时同时执行出队操作while(!q.empty()) &#123;    cout&lt;&lt;q.front();    q.pop_front();&#125;</code></pre></div><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><blockquote><p>相似的容器有: <a href="#deque">deque</a>(双端队列), <a href="#priority_queue">priority_queue</a>(优先队列)</p></blockquote><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>头文件为<code>#include&lt;stack&gt;</code>，是一种先进后出的结构，栈</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">stack&lt;int&gt;sk; &#x2F;&#x2F; 初始化一个空栈&#x2F;&#x2F; stack不支持列表参数形式初始化，但可以通过第二个参数改变修改底层容器后就可以使用该容器初始化vector&lt;int&gt;v&#123;1,2,3,4&#125;;stack&lt;int, vector&lt;int&gt; &gt;sk(v); &#x2F;&#x2F; 指定底层容器为vector&lt;int&gt;类型，就可以使用vector&lt;int&gt;进行初始化</code></pre></div><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; stack和queue一样基本是使用其先进后出和先进先出的逻辑，所以一般也不会用到在中间插值的操作&#x2F;&#x2F; 入栈sk.push(elem);&#x2F;&#x2F; 出栈sk.pop();&#x2F;&#x2F; 访问栈顶元素sk.top();&#x2F;&#x2F; 栈的大小sk.size();&#x2F;&#x2F; 判断栈是否为空sk.empty();&#x2F;&#x2F; 遍历&#x2F;&#x2F; 和queue一样，stack就不适合遍历，使用stack就是使用栈的特性，一般都是以empty()作为while判断条件然后循环出栈访问</code></pre></div><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><span id="set">Set</span></h2><p>对应头文件<code>#include&lt;set&gt;</code></p><p>set即集合，内部每个元素都是唯一的</p><h3 id="常见初始化"><a href="#常见初始化" class="headerlink" title="常见初始化"></a>常见初始化</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;set&gt;set&lt;int&gt; se; &#x2F;&#x2F; 定义一个空setset&lt;int&gt; se &#x3D; set&lt;int&gt;();&#x2F;&#x2F; 定义一个空setset&lt;int&gt;se(xset); &#x2F;&#x2F; 使用xset来初始化seset&lt;int&gt; se(a.begin(), a.end()); &#x2F;&#x2F; a可以是集合也可以是vector这种容器</code></pre></div><h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">se.insert(); &#x2F;&#x2F; 向集合添加一个元素se.insert(a.begin(), a.end()); &#x2F;&#x2F; 插入多个元素，a可以是vector或集合</code></pre></div><h3 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 删除容器中值为elem的元素se.erase(4);&#x2F;&#x2F; 任意位置删除一个元素set&lt;int&gt;::iterator it &#x3D; se.begin();se.erase(it);&#x2F;&#x2F; 清空所有元素st.clear();</code></pre></div><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 集合大小se.size();&#x2F;&#x2F; 集合是否为空st.empty();&#x2F;&#x2F; 指定元素个数，由于set中的元素都唯一使用此处count常用来判断是否存在该值st.count(elem);&#x2F;&#x2F; 指定元素是否存在se.find(elm) &#x2F;&#x2F; 返回迭代器位置，通过和se.end()判断是否存在</code></pre></div><h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 迭代器遍历set&lt;int&gt;::iterator it;for (it &#x3D; se.begin(); it !&#x3D; se.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; endl;&#125;&#x2F;&#x2F; for infor (int x : se) &#123;    cout&lt;&lt;x&lt;&lt;endl;&#125;</code></pre></div><blockquote><p>关联的容器有: <a href="#multiset">multiset</a></p></blockquote><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>pair的使用不用特意引入头文件，pair表示一种键值对类型</p><div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>严格来说不算一种容器，也不在STL标准库中，不过实际应用场景很丰富，经常和其他容器搭配使用</div><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pair&lt;int, stirng&gt;pa; &#x2F;&#x2F; 定义一个key为int，value为string的键值对pair&lt;int, string&gt;pa(1, &quot;value1&quot;); &#x2F;&#x2F; 定义同时初始化赋值make_pair(3, &quot;value3&quot;); &#x2F;&#x2F; 创建一个新的pair，类型为&lt;int, string&gt;pair&lt;int, string&gt;pa &#x3D; &#123;5, &quot;v5&quot;&#125;;</code></pre></div><p>pair在使用时很灵活，可以和多种容器一起使用，如何vector混合使用就可以保持图的到达关系列表</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;定义vector的类型为pairvector&lt;pair&lt;int, string&gt; &gt;v;&#x2F;&#x2F; 添加元素时可以使用v.push_back(pair&lt;int, string&gt;(2, &quot;value2&quot;));&#x2F;&#x2F; 或v.push_back(make_pair(3, &quot;value3&quot;));&#x2F;&#x2F; 或v.push_back(&#123;4, &quot;v5&quot;&#125;);</code></pre></div><p>和set一起使用就可以把无向图的边关系进行去重保存</p><p>==如果两个pair的first值和second值均相同时，则两个pair相等，在set中会被去重==</p><h3 id="值访问与修改"><a href="#值访问与修改" class="headerlink" title="值访问与修改"></a>值访问与修改</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pair&lt;int, string&gt;pa(1, &quot;value1&quot;);pa.first; &#x2F;&#x2F; 1;pa.second; &#x2F;&#x2F; &quot;value&quot;;&#x2F;&#x2F; 同时可以对键值进行修改pa.first &#x3D; 2;pa.second &#x3D; &quot;v2&quot;;</code></pre></div><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>头文件<code>#include&lt;map&gt;</code></p><p>提供键值对形式的结构</p><h3 id="常用初始化"><a href="#常用初始化" class="headerlink" title="常用初始化"></a>常用初始化</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">map&lt;string, int&gt;ma; &#x2F;&#x2F; 初始化一个key为string类型，value为int类型的mapmap&lt;string, int&gt;ma &#x3D; &#123; &#x2F;&#x2F; 列表初始化只适用于c++11及以上，注意兼容    &#123;&quot;key1&quot;, 1&#125;,    &#123;&quot;key2&quot;, 2&#125;,    &#123;&quot;key3&quot;, 3&#125;&#125;&#x2F;&#x2F; 不支持c++11就只能手动初始化了map&lt;string, int&gt;ma; &#x2F;&#x2F; 创建声明ma[&quot;key1&quot;] &#x3D; 1;ma.insert(pair&lt;string, int&gt;(&quot;key2&quot;, 2));</code></pre></div><h3 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; map中不支持重复的key值，所以重复添加相同的key值项时，本质类同更新ma[&quot;key1&quot;] &#x3D; 1; &#x2F;&#x2F; 定义key值为&quot;key1&quot;，value为1的键值对ma.insert(pair&lt;string, int&gt;(&quot;key2&quot;, 2)); &#x2F;&#x2F; 使用pair插入</code></pre></div><h3 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ma.erase(key); &#x2F;&#x2F; 基于键值对key值删除一个键值对ma.clear(); &#x2F;&#x2F; 清空map内所以键值对</code></pre></div><h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ma.find(key); &#x2F;&#x2F; 返回对应key的迭代器，和ma.end()对比判断是否存在该键值对ma.count(key); &#x2F;&#x2F; 查找对应key的键值对数量，若为0则不存在该key值</code></pre></div><h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 通用方法，迭代器map&lt;string, int&gt;::iterator it;for (it &#x3D; ma.begin(); it !&#x3D; ma.end(); it++) &#123;    cout&lt;&lt;&quot;key&#x3D;&quot;&lt;&lt;it-&gt;first&lt;&lt;&quot;,value&#x3D;&quot;&lt;&lt;it-&gt;second&lt;&lt;endl;&#125;&#x2F;&#x2F; 使用for infor (pair&lt;string, int&gt;pa : ma) &#123;    cout&lt;&lt;&quot;key&#x3D;&quot;&lt;&lt;pa.first&lt;&lt;&quot;,value&#x3D;&quot;&lt;&lt;pa.second&lt;&lt;endl;&#125;</code></pre></div><h2 id="priority-queue⭐"><a href="#priority-queue⭐" class="headerlink" title="priority_queue⭐"></a><span id="priority_queue">priority_queue</span>⭐</h2><p>头文件为<code>#include&lt;queue&gt;</code>，和<a href="#queue">queue</a>一直，基本操作也类似，区别在于priority_queue优先队列可以设置数据的优先级，优先级高的可以先出队，其本质是用一个堆实现，常用与大根堆和小根堆的使用</p><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">了解更多</a></p><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 默认创建是大根堆priority_queue&lt;int&gt;pq;&#x2F;&#x2F; 等价于priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt;pq;&#x2F;&#x2F; 小根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;pq;</code></pre></div><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 对应基本数据，在插入元素后内部堆结构会自行进行调整&#x2F;&#x2F; 添加元素到队尾并排序pq.push(elem);pq.emplace(elem); &#x2F;&#x2F; 和push底层实现有点差异实际使用上作用一致&#x2F;&#x2F; 出队pq.pop();&#x2F;&#x2F; 访问队首pq.top();&#x2F;&#x2F; 队列大小pq.size();&#x2F;&#x2F; 判空pq.empty();</code></pre></div><div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>当存储数据为pair是会先比较first的值然后再比较second的值，若是要使用自定义的数据结构就需要重载相关操作符</div><hr><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String不能算STL中的容器不过使用频率还是很高的，如果平时用的不是c++的话code的时候遇到还是会手生</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 截取子串s.substr(pos, n); &#x2F;&#x2F; 截取[pos, pos+n)的子串，当不填n时默认截取到末尾&#x2F;&#x2F; 替换s.replace(pos, n, s1); &#x2F;&#x2F; 把[pos, pos+n)的子串换成s1&#x2F;&#x2F; 查找s.find(s1);&#x2F;&#x2F;查找s中第一次出现s1的位置，并返回（包括0）string::size_type position;&#x2F;&#x2F;find 函数 返回jk 在s 中的下标位置position &#x3D; s.find(&quot;jk&quot;);bool isFind &#x3D; (position !&#x3D; s.npos);&#x2F;&#x2F;s.rfind(s1);&#x2F;&#x2F;查找s中最后一次出现s1的位置，并返回（包括0）s.find_first_of(s1);&#x2F;&#x2F;查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括0）s.find_last_of(s1);&#x2F;&#x2F;查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括0）s.find_first_not_of(s1);&#x2F;&#x2F;查找s中第一个不属于s1中的字符的位置，并返回（包括0）s.find_last_not_of(s1);&#x2F;&#x2F;查找s中最后一个不属于s1中的字符的位置，并返回（包括0）</code></pre></div><p>字符串转数字</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string s1 &#x3D; &quot;2147482&quot;, s2 &#x3D; &quot;-214748&quot;;string s3 &#x3D; &quot;214748666666663&quot;, s4 &#x3D; &quot;-21474836488&quot;;cout &lt;&lt; stoi(s1) &lt;&lt; endl;cout &lt;&lt; stoi(s2) &lt;&lt; endl;cout &lt;&lt; atoi(s3.c_str()) &lt;&lt; endl;cout &lt;&lt; atoi(s4.c_str()) &lt;&lt; endl;&#x2F;&#x2F; 也可以通过stringstream进行转换</code></pre></div><p>数字转string</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; c++ 11新特性int a &#x3D; 1;string as &#x3D; to_string(a);</code></pre></div><h1 id="其他容器收录"><a href="#其他容器收录" class="headerlink" title="其他容器收录"></a>其他容器收录</h1><p>这部分收录主要是个人觉得不是很常用的一些容器相关API整理</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a><span id="deque">deque</span></h2><p>头文件<code>#include &lt;deque&gt;</code></p><p>双端队列，相比queue队列来说，双端队列两头都可以入队出队，也支持删除中间的元素</p><h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">deque&lt;int&gt; a; &#x2F;&#x2F; 定义一个int类型的双端队列adeque&lt;int&gt; a(10); &#x2F;&#x2F; 定义一个int类型的双端队列a，并设置初始大小为10deque&lt;int&gt; a(10, 1); &#x2F;&#x2F; 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1deque&lt;int&gt; b(a); &#x2F;&#x2F; 定义并用双端队列a初始化双端队列bdeque&lt;int&gt; b(a.begin(), a.begin()+3); &#x2F;&#x2F; 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值，当然此处也可以使用vector来进行初始化&#x2F;&#x2F; 使用数组进行初始化int n[] &#x3D; &#123; 1, 2, 3, 4, 5 &#125;;deque&lt;int&gt; a(n, n + 5); deque&lt;int&gt; a(&amp;n[1], &amp;n[4]); &#x2F;&#x2F; 将n[1]、n[2]、n[3]作为双端队列a的初值</code></pre></div><p>源<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/linuxandmcu/p/10260124.html">[1]</span></a></sup></p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">de.push_back(elem); &#x2F;&#x2F; 从队尾入队de.push_front(elem); &#x2F;&#x2F; 从队头入队&#x2F;&#x2F; 任意位置插入一个元素deque&lt;int&gt;::iterator it &#x3D; de.begin();de.insert(it, 2);&#x2F;&#x2F; 任意位置插入n个相同元素de.insert(it, 3, 9); &#x2F;&#x2F; it为迭代器位置，插入3个9&#x2F;&#x2F; 也可以插入其他迭代器中间的一段数据de.insert(it, deq2.end() - 1, deq2.end());</code></pre></div><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">de.pop_back(elem); &#x2F;&#x2F; 从队尾出队de.pop_front(elem); &#x2F;&#x2F; 从队头出队de.erase(iterator it); &#x2F;&#x2F; 删除迭代器位置的元素de.erase(iterator first, iterator last); &#x2F;&#x2F; 删除迭代器范围中的元素</code></pre></div><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">deq[1]; &#x2F;&#x2F; 下标访问deq.at(i); &#x2F;&#x2F; at方法访问deq.front(); &#x2F;&#x2F; 访问队首元素deq.back(); &#x2F;&#x2F; 访问队尾元素</code></pre></div><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dep.size(); &#x2F;&#x2F; 大小deq.empty(); &#x2F;&#x2F; 判断空</code></pre></div><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a><span id="multiset">multiset</span></h2><p>头文件<code>#include &lt;set&gt;</code>和set在使用上大概一直，主要的区别在于set不允许重复的元素而multiset支持</p><p>相关初始化和使用方法如<a href="#set">set</a>一致</p><p>另外在使用<code>count()</code>方法时因为multiset允许重复元素，因此count方法将会返回元素的个数</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/linuxandmcu/p/10260124.html">https://www.cnblogs.com/linuxandmcu/p/10260124.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习资源</title>
    <link href="/blog/10465.html"/>
    <url>/blog/10465.html</url>
    
    <content type="html"><![CDATA[<p>关于iOS和前端的一些学习资源记录，其实在网上专门搜索下会发现还是有很多优质资源，相比国内一些<del>(专门捞钱)</del>网课培训班来说要好很多，基本来说大家都比较乐于分享学习资料，有种来之于互联网返以互联网的意思<font size=2><del>当然感觉国内某些网站注水太严重了，在百度上的seo还贼高</del></font></p><h2 id="内功篇"><a href="#内功篇" class="headerlink" title="内功篇"></a>内功篇</h2><ul><li><p><a href="https://www.bilibili.com/video/BV1Xx41117tr?from=search&seid=6571387686544901587">SICP</a>, 计算机程序的构造与解释，短时间上对开发编程没啥大用，但可以提高计算机素质<font size=2><del>装逼也不错</del></font></p></li><li><p><a href="https://leetcode-cn.com/">leetcode</a>，算法基础，同时leetcode上也有很多的求职面经，社区活跃度很高</p></li></ul><h2 id="iOS篇"><a href="#iOS篇" class="headerlink" title="iOS篇"></a>iOS篇</h2><blockquote><p> 现在iOS最新的开发资料基本都是<code>Swift</code>的了，不过忽略两者在具体语言特性和一小部分的方法差别外，可以把两者当做语法不通的iOS开发语言来看，虽然语法不同，不过在可读性上不会遇到太多问题</p></blockquote><h3 id="网站记录"><a href="#网站记录" class="headerlink" title="网站记录"></a>网站记录</h3><ul><li><p><a href="https://developer.apple.com/cn/develop/">apple develop</a>，最经典也最重要的当然就是apple的开发者模块，有很多开发者基本都是从这里开始的，其中的开发者文档对于新手来说也是很好的学习资源，当然主要还是偏工具书一点，如果把这个作为入门读本还是挺痛苦的(提升专业英语水平除外)</p></li><li><p><a href="https://podcasts.apple.com/cn/podcast/developing-ios-11-apps-with-swift/id1315130780">Developing-iOS-11-Apps-with-Swift</a> 斯坦福的一个网课，github上有人对视频做了翻译并上传到了b站等网站</p></li></ul><blockquote><p>♪(･ω･)ﾉ感谢</p><p>github翻译官 <a href="https://github.com/Apollonyan/Developing-iOS-11-Apps-with-Swift">https://github.com/Apollonyan/Developing-iOS-11-Apps-with-Swift</a></p><p>b站资源 <a href="https://www.bilibili.com/video/av16339375/">https://www.bilibili.com/video/av16339375/</a></p></blockquote><ul><li><p><a href="https://www.appcoda.com/category/tutorials/ios/">appcode</a> 有一些不错的<font size=1><del>免费的</del></font>学习资源，虽然是英文的，但现在的浏览器翻译功能已经很强大了，而且开发需要掌握的专业英语其实范围不是很大，平时多接触学习阅读应该不会有障碍<font size=1>(阅读快不快就不一定了)</font></p></li><li><p><a href="https://www.raywenderlich.com/">raywenderlich</a>，基础的学习入门网站吧，里面还有别的方向的学习资料</p></li></ul><h3 id="不错的博客"><a href="#不错的博客" class="headerlink" title="不错的博客"></a>不错的博客</h3><ul><li><p><a href="http://www.cocoachina.com/">CocoaChina</a>     全球最大苹果开发者中文社区</p></li><li><p><a href="https://juejin.cn/tag/iOS">掘金iOS专栏</a>     个人感觉掘金里的文章质量挺高的，基本没有大片复制粘贴或者给个跳转链接的事情存在</p></li></ul><h2 id="前端篇"><a href="#前端篇" class="headerlink" title="前端篇"></a>前端篇</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/2.html"/>
    <url>/blog/2.html</url>
    
    <content type="html"><![CDATA[<p>iOS的UI界面的编写现在基本分为三个流派</p><ul><li>手写代码</li><li>XIB</li><li>StoryBoard<br><a href="https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/">三者区别</a></li></ul><p><strong>本文主要介绍XIB的简单使用，基于XIB在界面上放几个按钮并生成点击事件代码</strong></p><p>以下代码及截图基于XCode12</p><h2 id="快速创建"><a href="#快速创建" class="headerlink" title="快速创建"></a>快速创建</h2><h3 id="1、创建文本对象"><a href="#1、创建文本对象" class="headerlink" title="1、创建文本对象"></a>1、创建文本对象</h3><p><img src="https://img-blog.csdnimg.cn/0c5097d6fc074ceb8843f186b23b7b0b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>自定义创建vc时勾选<code>create XIB file</code>，后将会自动创建xib文件，创建后如图<br><img src="https://img-blog.csdnimg.cn/68004983c2614a5187e05d0039dda252.png" alt="在这里插入图片描述"></p><h3 id="2、为XIB添加控件"><a href="#2、为XIB添加控件" class="headerlink" title="2、为XIB添加控件"></a>2、为XIB添加控件</h3><p><img src="https://img-blog.csdnimg.cn/1262fdbf6337497c9b1fd7f8fe26a924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选中xib文件后可以看到右侧出现了一个vc的UI展示图<br>点击右上角的+，可以拖动添加UI组件<br><img src="https://img-blog.csdnimg.cn/0c0a61cc3c564a80a2444c57377a5c26.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2cd52e87229a44c08a7480d376ef7fc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选中按钮控件后，点击右侧对应栏可以看到有关于该button对象的属性设置，比如title，type等，若要设置其控件view上的属性则在该栏下方的view部分，基于view可以设置按钮的背景色等</p><p><font color=blue>若右侧对应位置始终空白则可以重启Xcode<font size=2><del>(日常抽)</del></font></font></p><h3 id="3、在vc文件中生成对应属性及添加方法"><a href="#3、在vc文件中生成对应属性及添加方法" class="headerlink" title="3、在vc文件中生成对应属性及添加方法"></a>3、在vc文件中生成对应属性及添加方法</h3><p><img src="https://img-blog.csdnimg.cn/c1536d98db0e48b78dfd5cc5b508e2e0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击该项形成左右分屏，在一侧的分屏中显示对应vc的代码，一侧显示xib界面<br>按下<kbd>control</kbd> 同时拖动界面元素到代码处<br><img src="https://img-blog.csdnimg.cn/8519d858085b417c82fd3e2a405b9fef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时输入Name作为变量名后，将会自动生成属性<br><img src="https://img-blog.csdnimg.cn/75d81041f0f5418a88246fa9265c712a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color=blue>若此时提示connect failed，”xx” not found，首先可以尝试重启Xcode，无效的话再选择删除该自定义vc的hm文件并新建一个，同时新建文件无需带有xib文件</font></p><p>按钮属性添加完毕后添加点击事件<br><img src="https://img-blog.csdnimg.cn/e230ab279ca241ffb03d88864253f4a4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将组建拖到@Implentation中，可以看到会自动创建一个action准备连接，其中name为方法名</p><p><img src="https://img-blog.csdnimg.cn/f253f5ae92a247adaa068a1228e6645c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加后可一件形成了一个function</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>可以看到运行后界面显示和在预览中显示是一致的，点击后会调用之前添加的点击事件</p><p>至此，一个简单的demo就跑起来了，可以看到，相比手写UI，XIB上创建UI控件，位置布局，点击事件绑定省了很多事，特别是有时候需要做一个UIDemo时，使用XIB能更块的完成该demo的创建</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS提示音和音乐播放器</title>
    <link href="/blog/17462.html"/>
    <url>/blog/17462.html</url>
    
    <content type="html"><![CDATA[<h2 id="Audio-Toolbox"><a href="#Audio-Toolbox" class="headerlink" title="Audio Toolbox"></a>Audio Toolbox</h2><blockquote><p>The AudioToolbox framework provides interfaces for recording, playback, and stream parsing. In iOS, the framework provides additional interfaces for managing audio sessions.</p><p>Audio Toolbox框架主要是提供记录播放声音的接口</p></blockquote><p>本文主要记录该框架中的<code>Audio Services</code>和<code>Music Player</code>这两款和声音播放相关的模块</p><h3 id="Audio-Services"><a href="#Audio-Services" class="headerlink" title="Audio Services"></a>Audio Services</h3><blockquote><p>Play short sounds or trigger a vibration effect on iOS devices with the appropriate hardware.</p></blockquote><p>该模块主要是提供一些短音频或是震动效果，经常被用来实现自定义提示音的播放和管理。</p><div style="box-sizing: border-box; margin: 10px 0; border: 1px solid #a2a9b1; border-left:10px solid #f28500;padding: 10px">值得注意的是，音频文件时长需要短于30s，同时该接口不提供音频的定位、时间条管理，同时也不支持多音频同时播放(可以播放同时震动)</div><p>使用该模块主要分以下几个步骤</p><ul><li>创建声音对象</li><li>播放声音对象<ul><li>可指定播放+震动双重效果</li></ul></li><li>销毁声音对象</li></ul><h4 id="创建声音对象"><a href="#创建声音对象" class="headerlink" title="创建声音对象"></a>创建声音对象</h4><p><strong>API：</strong></p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">OSStatus AudioServicesCreateSystemSoundID(CFURLRef inFileURL, SystemSoundID *outSystemSoundID);</code></pre></div><p><strong>代码示例：</strong></p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; 引入头文件#import &lt;AVFoundation&#x2F;AVFoundation.h&gt;&#x2F;&#x2F; 基于文件资源创建声音对象&#x2F;&#x2F; 🌰，从bundle中获取声音资源- (BOOL) createSoundSourece: (NSString *)key withSoundID: (SystemSoundID*)soundID&#123;    if (!key || [key isEqualToString:@&quot;&quot;]) &#123;        return NO;    &#125;    NSBundle *bundle &#x3D; [self sourceBundle];    if (!bundle) &#123;        return NO;    &#125;    NSURL *url0 &#x3D; [bundle URLForResource:key withExtension:nil];    if (!url0) &#123;        return NO;    &#125;    &#x2F;&#x2F; 基于bundle中的资源创建声音对象    AudioServicesCreateSystemSoundID((__bridge CFURLRef)url0, soundID);    return YES;&#125;- (NSBundle *) sourceBundle &#123;    NSString *bundlePath &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;MediaBundle&quot; ofType:@&quot;bundle&quot;];    if (!bundlePath || [bundlePath isEqualToString:@&quot;&quot;]) &#123;        return nil;    &#125;    NSBundle *bundle &#x3D; [NSBundle bundleWithPath: bundlePath];    if (!bundle) &#123;        return nil;    &#125;    return bundle;&#125;</code></pre></div><p>如果不打算自定义声音的话可以直接使用系统自带的一些声音对象</p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">kSystemSoundID_Vibrate; &#x2F;&#x2F; 震动，支持iOS10+</code></pre></div><h4 id="播放声音"><a href="#播放声音" class="headerlink" title="播放声音"></a>播放声音</h4><p>基于创建使用对象进行使用的播放，目前官方提供了4个API，但主要还是归为两类，发布为播放系统使用，和带震动的播放系统声音</p><ul><li>播放系统声音</li></ul><p><strong>API</strong></p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">void AudioServicesPlaySystemSoundWithCompletion(SystemSoundID inSystemSoundID, void (^inCompletionBlock)(void));</code></pre></div><p><strong>使用🌰</strong></p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">AudioServicesPlaySystemSoundWithCompletion(soundID, ^()&#123;    &#x2F;&#x2F; 音频播放结束回调&#125;);</code></pre></div><p><font color=dark>需要特别注意的是，这个block回调不一定是播放完声音才会回调，必然在播放时手机处于静音状态，或声音对象对应的音频不存在时都会马上进入回调</font></p><p><font color=blue>因此在iOS5禁用获取手机是否静音后很多走三方就是通过播放一个一个特定长度音频文件，看其是否是立刻进入回调来判断手机是否处于静音状态</font></p><p>不需要关注其播放完成时间的API</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; void AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID);AudioServicesPlaySystemSound(soundID);</code></pre></div><p>其中如果soundID直接取<code>kSystemSoundID_Vibrate</code>的话就可以实只播放震动</p><ul><li>播放系统使用同时震动</li></ul><p>相关接口方法如上，也是有两个</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">AudioServicesPlayAlertSound(soundID);AudioServicesPlayAlertSoundWithCompletion(soundID, ^()&#123;    &#x2F;&#x2F; 音频播放结束回调&#125;);</code></pre></div><p>两个API在iOS版本上的支持性不同，具体使用时应当查看其available</p><p><font color=blue>另外需要注意的是，在播放长音频时(&lt;30s)<code>PlayAlertSound</code>只会震动一次，而不是随着铃声持续震动 </font></p><p>若想实现持续震动，可以借助带completion的接口实现，回调震动</p><p>若是觉得太过block来关注音频的播放完成时间不太方便的话，框架中还支持使用C方法作为回调方法，同时也支持移除对应的回调方法</p><ul><li>AudioServicesAddSystemSoundCompletion             - 注册一个C方法作为使用播放完毕的回调通知方法</li><li>AudioServicesRemoveSystemSoundCompletion     - 移除一个注册的播放完毕方法</li><li>AudioServicesSystemSoundCompletionProc           - 播放完成后唤起的方法</li></ul><h4 id="注销声音对象"><a href="#注销声音对象" class="headerlink" title="注销声音对象"></a>注销声音对象</h4><p>播放完后有时候需要注销声音对象</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; OSStatus AudioServicesDisposeSystemSoundID(SystemSoundID inSystemSoundID);AudioServicesDisposeSystemSoundID(soundID);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法中常用的c++方法</title>
    <link href="/blog/57158.html"/>
    <url>/blog/57158.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在使用STL的容器和算法库的一些算法时，需要注意引入对应的头文件，或者使用#include&lt;bits/stdc++.h&gt;万能头文件后，使用前需要确定是否支持，目前主流的oj均已支持该头文件</p></blockquote><h1 id="容器篇"><a href="#容器篇" class="headerlink" title="容器篇"></a><a href="./algosupportcontainer">容器篇</a></h1><h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>引入</p><p><code>#include&lt;algorithm.h&gt;</code></p><h4 id="容器最值"><a href="#容器最值" class="headerlink" title="容器最值"></a>容器最值</h4><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt;v&#123;0,1,2,3,4,1,2,-1&#125;;cout&lt;&lt;*min_element(v.begin(),v.end())&lt;&lt;endl;&#x2F;&#x2F;最小元素cout&lt;&lt;*max_element(v.begin(),v.end())&lt;&lt;endl;&#x2F;&#x2F;最大元素</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于iOS的通知</title>
    <link href="/blog/4702.html"/>
    <url>/blog/4702.html</url>
    
    <content type="html"><![CDATA[<p>iOS中存在三种常见的事件通知方式：NSNofiticationCenter、KVO Notification 和 User Notifications，其中 User Notifications，就是本文将要探讨的用户通知</p><p>用户通知就是在我们使用手机时会出现的一些与App相关的通知栏消息</p><p>用户通知又分为两类：<code>本地通知</code>和<code>远程通知(推送通知)</code></p><p>本地通知：是由 App 发送到当前设备上，不需要网络支持</p><p>远程通知：是由 App 的服务器发送到苹果的 APNs 服务器，并由 APNs 服务器转发到相应设备(由 App 服务器指定接收通知的设备)</p><p>这两者对用户的表现形式是相同的，两则均可以采用通知栏通知、App桌面图标右上角角标和提示音的方式通知用户</p><h3 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a>本地通知</h3><p><font color=blue><code>iOS8 -- iOS10</code></font>针对本地用户通知的对象为<code>UILocalNotification</code>， 而<font color=dark>iOS10</font>后对通知相关api进行了合并整理相关api为<code>UNNotification</code></p><h4 id="1、申请权限"><a href="#1、申请权限" class="headerlink" title="1、申请权限"></a>1、申请权限</h4><ul><li>iOS10及以上</li></ul><div class="code-wrapper"><pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">UNUserNotificationCenter * center &#x3D; [UNUserNotificationCenter currentNotificationCenter];    &#x2F;&#x2F;请求获取通知权限（角标，声音，弹框）    [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge |                                             UNAuthorizationOptionSound |                                             UNAuthorizationOptionAlert)                          completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;        if (granted) &#123;            &#x2F;&#x2F;获取用户是否同意开启通知            NSLog(@&quot;开启通知成功!&quot;);        &#125;    &#125;];</code></pre></div><ul><li>iOS8 - iOS10</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIUserNotificationSettings *setting &#x3D; [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert categories:nil];[[UIApplication sharedApplication] registerUserNotificationSettings:setting];</code></pre></div><p>在实际使用时，有时需要获取当前的授权情况</p><ul><li>iOS10</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; 通过getNotificationSettingsWithCompletionHandler的回调进行判断UNUserNotificationCenter *center &#x3D; [UNUserNotificationCenter currentNotificationCenter];        [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;            if (settings.notificationCenterSetting &#x3D;&#x3D; UNNotificationSettingEnabled) &#123;                isOn &#x3D; YES;                NSLog(@&quot;打开了通知&quot;);            &#125;else &#123;                isOn &#x3D; NO;                NSLog(@&quot;关闭了通知&quot;);               [self showAlertView];            &#125;            [self dealAuthorizationStatus: settings.authorizationStatus];        &#125;];&#x2F;&#x2F; settings.authorizationStatus包括多种状态可进行一一配置，至于settings.notificationCenterSetting看文档没看出到底是什么，可以作为进一步判断吧</code></pre></div><ul><li>iOS8 - iOS10</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">if ([[UIApplication sharedApplication] currentUserNotificationSettings].types &#x3D;&#x3D; UIUserNotificationTypeNone)&#123;            NSLog(@&quot;关闭了通知&quot;);        &#125;else &#123;            NSLog(@&quot;打开了通知&quot;);        &#125;</code></pre></div><h4 id="2、创建通知"><a href="#2、创建通知" class="headerlink" title="2、创建通知"></a>2、创建通知</h4><ul><li>iOS10</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UNMutableNotificationContent *content &#x3D; [[UNMutableNotificationContent alloc] init];    content.title &#x3D; @&quot;测试标题&quot;;&#x2F;&#x2F;    content.subtitle &#x3D; @&quot;本地通知副标题&quot;;    content.body &#x3D; @&quot;内容&quot;;    &#x2F;&#x2F;角标数量    content.badge &#x3D; @1;    content.userInfo &#x3D; userInfo;    &#x2F;&#x2F;设置通知声音    UNNotificationSound *sound &#x3D; [UNNotificationSound defaultSound];    content.sound &#x3D; sound;</code></pre></div><p>创建UNNotificationRequest</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F;设置时间容器：传人date中所有时间元素放入时间容器NSDateComponents * components &#x3D; [[NSCalendar currentCalendar]                                     components:NSCalendarUnitYear |                                     NSCalendarUnitMonth |                                     NSCalendarUnitWeekday |                                     NSCalendarUnitDay |                                     NSCalendarUnitHour |                                     NSCalendarUnitMinute |                                     NSCalendarUnitSecond                                     fromDate:date];&#x2F;&#x2F;设置UNCalendarNotificationTrigger&#x2F;&#x2F;repeats: 设置是否重复UNCalendarNotificationTrigger * trigger &#x3D; [UNCalendarNotificationTrigger                                             triggerWithDateMatchingComponents:components                                             repeats:repeat]; &#x2F;&#x2F; 多少秒后发送,可以将固定的日期转化为时间&#x2F;&#x2F; NSTimeInterval time &#x3D; [[NSDate dateWithTimeIntervalSinceNow:10] timeIntervalSinceNow];&#x2F;&#x2F;NSTimeInterval time &#x3D; 10;&#x2F;&#x2F; repeats，是否重复，如果重复的话时间必须大于60s，要不会报错&#x2F;&#x2F; UNTimeIntervalNotificationTrigger *trigger &#x3D; [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:time repeats:NO];&#x2F;&#x2F;设置UNNotificationRequest&#x2F;&#x2F;identifer:设置通知标识符或者说通知名字&#x2F;&#x2F; 添加通知的标识符，可以用于移除，更新等操作NSString *identifier &#x3D; @&quot;noticeId&quot;;UNNotificationRequest *request &#x3D; [UNNotificationRequest requestWithIdentifier:identifer content:content trigger:trigger];</code></pre></div><p>添加通知</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F;把通知加到UNUserNotificationCenter, 到指定触发点会被触发[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123;    if (error) &#123;        NSLog(@&quot;通知添加失败:%@&quot;,error);    &#125; else &#123;        NSLog(@&quot;通知添加成功&quot;);    &#125;&#125;];</code></pre></div><ul><li>iOS8 - iOS10</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UILocalNotification *notif &#x3D; [[UILocalNotification alloc] init];        &#x2F;&#x2F; 发出推送的日期        notif.fireDate &#x3D; [NSDate dateWithTimeIntervalSinceNow:10];        &#x2F;&#x2F; 推送的内容        notif.alertBody &#x3D; @&quot;你已经10秒没出现了&quot;;        &#x2F;&#x2F; 可以添加特定信息        notif.userInfo &#x3D; @&#123;@&quot;noticeId&quot;:@&quot;00001&quot;&#125;;        &#x2F;&#x2F; 角标        notif.applicationIconBadgeNumber &#x3D; 1;        &#x2F;&#x2F; 提示音        notif.soundName &#x3D; UILocalNotificationDefaultSoundName;        &#x2F;&#x2F; 每周循环提醒        notif.repeatInterval &#x3D; NSCalendarUnitWeekOfYear;                [[UIApplication sharedApplication] scheduleLocalNotification:notif];</code></pre></div><h4 id="3、取消通知"><a href="#3、取消通知" class="headerlink" title="3、取消通知"></a>3、取消通知</h4><ul><li>iOS10</li></ul><p>移除某个通知</p><div class="code-wrapper"><pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">&#x2F;&#x2F;找到要取消的通知名字NSMutableArray * names &#x3D; [[NSMutableArray alloc]initWithObjects:notificationName, nil];&#x2F;&#x2F;批量取消这些通知[[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:names];</code></pre></div><p>移除全部通知</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UNUserNotificationCenter *center &#x3D; [UNUserNotificationCenter currentNotificationCenter];[center removeAllPendingNotificationRequests];</code></pre></div><ul><li>iOS8 - iOS10</li></ul><p>移除某个通知</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSArray *array&#x3D;[[UIApplication sharedApplication] scheduledLocalNotifications];        for (UILocalNotification *localNotification in array)&#123;            NSDictionary *userInfo &#x3D; localNotification.userInfo;            NSString *obj &#x3D; [userInfo objectForKey:@&quot;noticeId&quot;];            if ([obj isEqualToString:noticeId]) &#123;                [[UIApplication sharedApplication] cancelLocalNotification:localNotification];            &#125;        &#125;</code></pre></div><p>移除全部通知</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[[UIApplication sharedApplication] cancelAllLocalNotifications];</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的流程归纳为：</p><ul><li>判断是否有推送权限，无则申请权限</li><li>创建通知(可定义通知的文本内容，提示音，角标等)<ul><li>设置通知内容UNMutableNotificationContent</li><li>设置通知的时间容器和之前创建的content，生成UNNotificationRequest</li></ul></li><li>添加通知，UNUserNotificationCenter的addNotificationRequest：</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS存储-沙盒机制</title>
    <link href="/blog/59499.html"/>
    <url>/blog/59499.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>iOS 每个 APP 都有自己对应的存储空间，这个存储空间叫做沙盒。每个应用程序之间不能相互访问非本程序的沙盒(前提是没越狱)。沙盒的作用就是存储数据，每个沙盒就相当于每个每个应用的系统目录。</p></blockquote><h3 id="iOS中一些存储形式"><a href="#iOS中一些存储形式" class="headerlink" title="iOS中一些存储形式"></a>iOS中一些存储形式</h3><h4 id="1、Bundle"><a href="#1、Bundle" class="headerlink" title="1、Bundle"></a>1、Bundle</h4><p>bundle就是通常所说的应用程序在手机里面的安装路径，是一个目录，这个目录就是程序的 main bundle。这个目录里面包含nib文件<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Nib文件是一种特殊类型的资源文件，它用于保存iPhone OS或Mac OS X应用程序的用户接口">[1]</span></a></sup>、编译代码、以及其他资源的目录等。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">比如一些plist文件，貌似通过外部引入的bundle资源最后也会在mainBundle中</code></pre></div> <div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; oc中获取该bundle对象NSBundle *myBundle &#x3D; [NSBundle mainBundle];NSString *myBundlePath &#x3D; [NSBundle mainBundle].bundlePath;&#x2F;&#x2F; 从bundle中获取资源对象NSString *imagePath &#x3D; [[NSBundle mainBundle]pathForResource:@&quot;雨滴&quot; ofType:@&quot;png&quot;];imageView.image &#x3D; [[UIImage alloc]initWithContentsOfFile:imagePath];</code></pre></div><h4 id="2、沙盒目录中的其他目录"><a href="#2、沙盒目录中的其他目录" class="headerlink" title="2、沙盒目录中的其他目录"></a>2、沙盒目录中的其他目录</h4><ul><li>Documents：用于存放程序中的文件数据，应用程序在运行时生成的一些需要长久保存的数据（比如：游戏进度存档、应用程序个人设置等等），通过 iTunes、iCloud 备份时, 会备份这个目录下的数据，此目录下保存相对重要的数据。</li><li>Library 包含Caches和Preferences⼦目录<ul><li>Caches：存放缓存文件，从网络上下载的文件或者数据（如：音乐缓存、图片缓存等），此目录下的文件不会在应用退出时自动删除 ，需要程序员手动清除改目录下的数据。iTunes、iCloud 备份时不会备份此目录下的数据。主要用于保存应用在运行时生成的需要长期使用的数据，一般用于存储体积较大，不需要备份的非重要数据。<mark>当系统磁盘空间非常低时，系统可能会在极少数情况下删除Caches目录</mark></li><li>Preferences存放的是基于<code>NSUserDefaults</code>的设置数据，文件格式为 “plist”。设置应用的一些功能会在该目录中查找相应设置的信息，iTunes、iCloud备份时会备份此目录下的数据。该目录由系统自动管理，通常用来储存一些基本的应用配置信息。比如账号密码、自动登录等。</li></ul></li><li>tmp：存放应用运行时产生的一些临时数据和文件，当应用程序退出、系统磁盘空间不足、手机重启时，都会自动清除该目录的数据。无需程序员手动清除该目录中的数据，iTunes、iCloud备份时不会备份此目录。</li><li>xxx.app (应用程序包)：包含程序中的nib⽂件、图片、音频等资源。</li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">Document : 存储用户数据,需要备份的信息Library&#x2F;Caches : 存储缓存文件,程序专用的支持文件Library&#x2F;Preferences : 存储应用程序的偏好设置⽂件tmp: 存储临时文件,比如下载的zip包,解压后的再删除xxx.app: 应用程序包iTunes在与iPhone同步时，会备份 &#96;Documents&#96; 和 &#96;Preferences&#96; 目录下的⽂件 。</code></pre></div><hr><p>获取程序的根目录：</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSString *homeDirectory &#x3D; NSHomeDirectory();NSLog(@&quot;homeDirectory &#x3D; %@&quot;,homeDirectory);</code></pre></div><p>获取document目录：</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSString *documentPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSLog(@&quot;documentPath &#x3D; %@&quot;,documentPath);</code></pre></div><p>获取Caches目录：</p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">NSString *cachesPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSLog(@&quot;cachesPath &#x3D; %@&quot;,cachesPath);</code></pre></div><p>获取Library目录：</p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">NSString *libraryPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject];NSLog(@&quot;libraryPath &#x3D; %@&quot;,libraryPath);</code></pre></div><p>获取Tmp目录：</p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">NSString *tmpDirectory &#x3D; NSTemporaryDirectory();NSLog(@&quot;tmpDirectory &#x3D; %@&quot;,tmpDirectory);</code></pre></div><p>获取 preferences 路径:</p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">&#x2F;&#x2F; 由系统维护,不需要我们手动获取文件目录.可借助 UserDefault 维护</code></pre></div><p>获取xxx.app程序包：</p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">NSBundle *myBundle &#x3D; [NSBundle mainBundle];NSLog(@&quot;app程序包 &#x3D; %@&quot;,myBundle);</code></pre></div><h3 id="特殊存储-钥匙串Keychain"><a href="#特殊存储-钥匙串Keychain" class="headerlink" title="特殊存储-钥匙串Keychain"></a>特殊存储-钥匙串Keychain</h3><hr><blockquote><p>Keychain可以包含任意数量的keychain item(keychain item称为SecItem,但它是存储在CFDictionary中的).每一个keychain item包含数据和一组属性。SecItem有五类：通用密码、互联网密码、证书、密钥和身份。在大多数情况下，我们用到的都是通用密码</p><p>在macOS中，当keychain被锁的时候加密的item没办法访问，如果你想要该问被锁的item，就会弹出一个对话框，需要你输入对应keychain的密码。当然，未有密码的keychain你可以随时访问。但在iOS中，你只可以访问你自已的keychain items</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;&#x2F; Keychain Services 是 macOS 和 iOS 都提供一种安全的存储敏感信息的工具,是一个安全容器，是一种存储在硬盘上的加密的数据库&#x2F;&#x2F; 钥匙串的存储是和沙盒无关的，所有的钥匙串在一个大的保险箱中&#x2F;&#x2F; 因此即使删除了app依旧可以获取从钥匙串中获取数据&#x2F;&#x2F; keychain也分为私有区和公有区</code></pre></div><ul><li>数据并不存放在App的Sanbox中，即使删除了App，资料依然保存在keychain中。如果重新安装了app，还可以从keychain获取数据</li><li>keychain的数据可以通过group方式，让程序可以在App间共享。不过得要相同TeamID<ul><li>在需要进行钥匙串分享时，需要打开相应的Capabilities（Keychain Sharing权限）</li></ul></li><li>keychain的数据是经过加密的</li></ul><h4 id="keychain的存取"><a href="#keychain的存取" class="headerlink" title="keychain的存取"></a>keychain的存取</h4><p><font color=blue>keychain中的数据子项是以item的形式存在的</font></p><p><img src="https://user-gold-cdn.xitu.io/2019/2/18/169001db39291baf?imageView2/0/w/1280/h/960/ignore-error/1" alt="把数据和属性存储到keychain中"></p><div class="code-wrapper"><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">&#x2F;&#x2F; 获取itemKeychainItemWrapper *keychainItem &#x3D;         [[KeychainItemWrapperalloc]initWithIdentifier:@&quot;UUID&quot;accessGroup:nil];NSString *uuidStr &#x3D; [keychainItemobjectForKey:(__bridgeid)kSecValueData];if (!uuidStr || uuidStr.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;代表里面还没有存值       NSString *myUUIDStr &#x3D; [[[UIDevice currentDevice] identifierForVendor]UUIDString];        [keychainItem setObject:myUUIDStr forKey:(__bridgeid)kSecValueData];        str &#x3D; myUUIDStr;&#125; else&#123;    str &#x3D; [keychainItem objectForKey:(__bridgeid)kSecValueData];&#125;MYLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%@&quot;,str);</code></pre></div><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Nib文件是一种特殊类型的资源文件，它用于保存iPhone OS或Mac OS X应用程序的用户接口<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OC基础:UIWindow和UIViewController</title>
    <link href="/blog/44224.html"/>
    <url>/blog/44224.html</url>
    
    <content type="html"><![CDATA[<ul><li><p>UIWindow是一种特殊的UIView，通常在一个应用中只会有一个UIWindow。</p></li><li><p>在ios程序启动完成后，建立的第一个视图控件就是UIWindow，接着创建一个控制器的View，最后将控制器的View添加到UIWindow上，于是控制器的View就是显示到屏幕上了。</p></li><li><p>一个ios程序之所以能显示在屏幕上，完全是因为它有UIWindow。也就是说，没有UIWindow就看不到任何UI界面。</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;    &#x2F;&#x2F; Override point for customization after application launch.    &#x2F;&#x2F; 1.创建窗口    self.window &#x3D; [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];    &#x2F;&#x2F; 2.加载storyboard文件，创建控制器    &#x2F;&#x2F; name:就是storyboard文件名    &#x2F;&#x2F; bundle:主bundle,传入nil，表示主bundle    UIStoryboard *storyboard &#x3D; [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];    &#x2F;&#x2F; 通过storyboard对象创建控制器    &#x2F;&#x2F; instantiateInitialViewController：加载storyboard箭头指向的控制器    UIViewController *rootVc &#x3D; [storyboard instantiateInitialViewController];    &#x2F;&#x2F; 3.设置窗口的根控制器，并且显示窗口    self.window.rootViewController &#x3D; rootVc;    &#x2F;&#x2F; 4.显示窗口    [self.window makeKeyAndVisible];    return YES;&#125;</code></pre></div><h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><p>画布视图</p><p>常用方法属性及描述</p><blockquote><p><strong>ios坐标系统</strong><br>ios以<mark>左上角</mark>为坐标原点(0,0)，以原点向右侧为X轴正方向，原点下侧为Y轴正方向</p><p>ios采用CGPoint来表示点在坐标系上X、Y位置。我们可以通过CGPointMake(x,y)来创建一个坐标点：CGPoint point = CGPointMake(80,40)</p><p>同时，ios采用CGSize来表示视图的宽度和高度，即视图的大小。我们可以通过CGSizeMake(width,height)来创建一个矩形的大小，如CGSize size = CGSizeMake(144,72)将创建一个宽度为144，高度为72的矩形大小。</p><p>而CGRect则是结合了CGPoint和CGSize，用来表示矩形的位置和大小。它的origin表示矩形左上角所在位置(CGPoint)，size表示矩形的大小(CGSize)。</p><p>作者：丸_子<br>链接：<a href="https://www.jianshu.com/p/c16c32c45862">https://www.jianshu.com/p/c16c32c45862</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><h5 id="frame：描述当前视图在其父视图中的位置和大小。"><a href="#frame：描述当前视图在其父视图中的位置和大小。" class="headerlink" title="frame：描述当前视图在其父视图中的位置和大小。"></a>frame：描述当前视图在其父视图中的位置和大小。</h5><p>坐标系在是父视图</p><blockquote><p>The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.</p><p>描述view在其所归属的父view上的位置描述</p></blockquote><blockquote><p>Changing the frame rectangle automatically redisplays the view without calling its <code>drawRect:</code>If you want UIKit to call the <a href="doc://com.apple.documentation/documentation/uikit/uiview/1622529-drawrect?language=objc"><code>drawRect:</code></a> method when the frame rectangle changes, set the <a href="doc://com.apple.documentation/documentation/uikit/uiview/1622619-contentmode?language=objc"><code>contentMode</code></a> property to <a href="doc://com.apple.documentation/documentation/uikit/uiviewcontentmode/uiviewcontentmoderedraw?language=objc"><code>UIViewContentModeRedraw</code></a>.</p><p>当我们修改一个view的frame时，框架会自动重新显示视图无需手动调用 drawRect方法(新的frame将在视图上自动生效)</p></blockquote><h5 id="bounds：描述当前视图在其自身坐标系统中的位置和大小"><a href="#bounds：描述当前视图在其自身坐标系统中的位置和大小" class="headerlink" title="bounds：描述当前视图在其自身坐标系统中的位置和大小"></a>bounds：描述当前视图在其自身坐标系统中的位置和大小</h5><p>坐标系是自己</p><blockquote><p>The bounds rectangle, which describes the view’s location and size in its own coordinate system.</p><p>描述其在自己的坐标系中的位置和大小</p></blockquote><img src="https://upload-images.jianshu.io/upload_images/154112-636352bd35d9594a.png?imageMogr2/auto-orient/strip|imageView2/2/w/987" alt="img" style="zoom:50%;" /><h5 id="center：描述当前视图的中心点在其父视图中的位置。"><a href="#center：描述当前视图的中心点在其父视图中的位置。" class="headerlink" title="center：描述当前视图的中心点在其父视图中的位置。"></a>center：描述当前视图的中心点在其父视图中的位置。</h5><blockquote><p>The center point of the view’s frame rectangle.</p><p>描述其在父视图中的中心位置</p></blockquote><p>center和frame的修改都会自动修改其他的相关属性，当需要移动一个view的位置时可以直接修改其center而其frame也会自动修改</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="addSubview"><a href="#addSubview" class="headerlink" title="addSubview:"></a>addSubview:</h5><p>添加子视图</p><h5 id="bringSubviewToFront"><a href="#bringSubviewToFront" class="headerlink" title="bringSubviewToFront:"></a>bringSubviewToFront:</h5><p>把某个子视图拉到最前面来(在子视图数组的最后一个)</p><h5 id="sendSubviewToBack"><a href="#sendSubviewToBack" class="headerlink" title="sendSubviewToBack:"></a>sendSubviewToBack:</h5><p>把某个子视图放到最后(在子视图数组的第一个)</p><h5 id="removeFromSuperview"><a href="#removeFromSuperview" class="headerlink" title="removeFromSuperview"></a>removeFromSuperview</h5><p>把自己从父视图中移除</p><p><font color=blue>如果把viewcontroller的rootView执行了removeFromSuperview后就视图调试器而言这个viewcontroller都没了</font></p><h5 id="isDescendantOfView"><a href="#isDescendantOfView" class="headerlink" title="isDescendantOfView:"></a>isDescendantOfView:</h5><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (BOOL)isDescendantOfView:(UIView *)view;</code></pre></div><p><code>Descendant</code> 后裔</p><p>判断自己是否为view的子视图</p><h5 id="sizeToFit-和sizeThatFits"><a href="#sizeToFit-和sizeThatFits" class="headerlink" title="sizeToFit: 和sizeThatFits:"></a>sizeToFit: 和sizeThatFits:</h5><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">- (CGSize)sizeThatFits:(CGSize)size;- (void)sizeToFit;</code></pre></div><p>sizeThatFits: 会计算出最优的 size 但是不会改变 自己的 size，而 sizeToFit: 会计算出最优的 size 而且会改变自己的 size。</p><p><em><strong>当调用 sizeToFit 后会调用 sizeThatFits 方法来计算 UIView 的 bounds.size 然后改变 frame.size</strong></em></p><p>一般UILabel使用来调整大小</p><p>对于单行label差别不大，对于需要自动换行的有些区别</p><p><img src="https://img-blog.csdn.net/20170820230557917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVhbmdmZWk3MTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h2><p>UIViewController有一个UIView根视图，而vc管理的就是这个根视图view的继承，子视图管理</p><blockquote><p>The view stored in this property represents the root view for the view controller’s view hierarchy. The default value of this property is <code>nil</code>.</p><p>If you access this property and its value is currently <code>nil</code>, the view controller automatically calls the <a href="doc://com.apple.documentation/documentation/uikit/uiviewcontroller/1621454-loadview?language=objc"><code>loadView</code></a> method and returns the resulting view.</p><p>UIViewController的view默认是nil，但当你调用它时会自动调用vc的loadView方法创建view并返回</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="presentingViewController和presentedViewController"><a href="#presentingViewController和presentedViewController" class="headerlink" title="presentingViewController和presentedViewController"></a>presentingViewController和presentedViewController</h4><p>presentingViewController表示呈现此视图控制器的视图控制器， presentedViewController表示视图控制器由该视图控制器呈现</p><p>A present B，A就是presentingViewController，B是presentedViewController，同时在执行present时<code>A.presentedViewController == B</code></p><div style="background: gold;">需要注意的是presenting并不是指打开它的控制器，在某些情况下</div><ul><li>A</li></ul><img src="https://upload-images.jianshu.io/upload_images/1966717-054b2ffbe1f7358a.png?imageMogr2/auto-orient/strip|imageView2/2/w/852/format/webp" alt="img" style="zoom:67%;" /><p>Ans: navigationController</p><ul><li><p>B</p><p><img src="https://upload-images.jianshu.io/upload_images/1966717-40f1c832cdc313e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>Ans: tabbarController</p></li></ul><p style="background:gold">在一个有导航控制器的控制器P中加入了子控制器Q，然后添加了Q的view，这个Q就可以使用self.navigationController进行跳转，Q是利用的P的导航控制器进行跳转。也就是说Q的关于控制器的操作都被P给处理了。那新加入一个问题：如果在Q中present出来一个界面R，那这个R的presentingViewController是谁呢？ 是的，是P。此时已经出现了刚才说的问题，Q打开了R，但是R的presentingViewController却是P。这时因为Q是P的子控制器。</p><p><font color=red>当某个控制器有父控制器的时候，它的presentingViewController是父控制器的presentingViewController</font></p><p>但！</p><p>可以指定presentingViewController为打开它的控制器</p><blockquote><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">@property(nonatomic,assign) BOOL definesPresentationContext;@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle;</code></pre></div><p>modalPresentationStyle属性决定了将要present的控制器以何种方式展现，默认值为UIModalTransitionStyleCoverVertical。如果把一个控制器的definesPresentationContext属性设置为YES，那么在需要进行UIModalPresentationCurrentContext类型的跳转的时候，UIKit会使用视图层级内的这个控制器来进行跳转。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">avc.definesPresentationContext &#x3D; falseavc.modalPresentationStyle &#x3D; .currentContext</code></pre></div><p>作者：XueYongWei<br>链接：<a href="https://www.jianshu.com/p/dd6180bc340a">https://www.jianshu.com/p/dd6180bc340a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h4 id="navigationController"><a href="#navigationController" class="headerlink" title="navigationController"></a>navigationController</h4><blockquote><p>The nearest ancestor in the view controller hierarchy that is a navigation controller.</p><p>在vc继承树中最近的navigationController</p><p>If the view controller or one of its ancestors is a child of a navigation controller, this property contains the owning navigation controller. This property is <code>nil</code> if the view controller is not embedded inside a navigation controller.</p></blockquote><h4 id="modalPresentationStyle"><a href="#modalPresentationStyle" class="headerlink" title="modalPresentationStyle"></a>modalPresentationStyle</h4><blockquote><p>Presents a view controller modally.</p><p>一般在使用presentViewController:animated:completion:时使用</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear:"></a>viewWillAppear:</h4><blockquote><p>Notifies the view controller that its view is about to be added to a view hierarchy.</p><p>一个视图即将加到继承树上</p></blockquote><h4 id="viewDidAppear"><a href="#viewDidAppear" class="headerlink" title="viewDidAppear:"></a>viewDidAppear:</h4><blockquote><p>Notifies the view controller that its view was added to a view hierarchy.</p></blockquote><hr><p><code>loadView</code>：是开始加载<code>view</code>的起始方法，除非手动调用，否则在<code>ViewController</code>的生命周期中只调用一次。</p><p><code>viewDidLoad</code>：是我们最常用的方法，类成员对象和变量的初始化我们都会放在这个方法中。在创建类后无论视图展现还是消失，这个方法也只会在布局是调用一次。</p><p><code>viewWillAppear:(BOOL)animated</code>：方法 是在视图将要展现出来的时候调用。</p><p><code>viewWillLayoutSubviews</code>：方法是在将要布局子视图的时候调用。</p><p><code>viewDidLayoutSubviews</code>：方法是在子视图布局完成后调用。</p><p><code>viewDidAppear:(BOOL)animated</code>：方法是视图已经出现。</p><p><code>viewWillDisappear:(BOOL)animated</code>：方法是视图即将消失。</p><p><code>viewDidDisappear:(BOOL)animated</code>：视图已经消失。</p><p><code>dealloc</code>：<code>ViewController</code>被释放时调用。</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="dismissViewControllerAnimated"><a href="#dismissViewControllerAnimated" class="headerlink" title="dismissViewControllerAnimated"></a>dismissViewControllerAnimated</h4><blockquote><p>Dismisses the view controller that was presented modally by the view controller.</p><p>退出模态</p></blockquote><p><mark color=pink>dismissViewControllerAnimated应该遵循谁present谁dimiss，类似MVC中的谁创建谁治理，因此应该是由present出它的vc进行dismiss</mark></p><p><a href="https://www.jianshu.com/p/dd6180bc340a">https://www.jianshu.com/p/dd6180bc340a</a></p><p>但在日常开发中基本都是presented的vc自己dismiss，只是因为iOS系统做了优化，如果一个vc执行了dismiss时，且它没有presented的vc那么就会让它的presentingvc执行dismiss；若其有presented的vc那么就会把其presented的vc移除</p><p>需要注意的是如果A present B，B present C，… ， 一直到E，即A-&gt;B-&gt;C-&gt;D-&gt;E;</p><p>此时若A 执行了dismissView… 那么BCDE都会被dismiss掉，执行顺序为E-&gt;D-&gt;C-&gt;B</p><p>这个过程就很有递归的感觉，已知dismiss一个vc时需要把他上面的vc都dismiss掉，所以过程上有点类似于</p><div class="code-wrapper"><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (void) myDissmiss: vc &#123;    if(vc.presetedViewController &#x3D;&#x3D; nil) &#123;        [vc.presentingViewController dismiss];        return;    &#125;if (vc.presentedViewController) &#123;myDissmiss(vc.presentedViewController)&#125;    &#125;</code></pre></div><img src="https://upload-images.jianshu.io/upload_images/141604-f5a367e9bbfcaf10.png?imageMogr2/auto-orient/strip|imageView2/2/w/751" alt="img" style="zoom:80%;" /><p>可恶原来 [self dismiss…]的本质是present它的上层执行dissmiss啊</p><h4 id="presentViewController-animated-completion"><a href="#presentViewController-animated-completion" class="headerlink" title="presentViewController:animated:completion:"></a>presentViewController:animated:completion:</h4><blockquote><p>Presents a view controller modally.</p><p>添加模态</p></blockquote><h2 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h2><blockquote><p>A container view controller that defines a stack-based scheme for navigating hierarchical content.</p><p>基于栈模式的视图控制器容器</p></blockquote><p>UINavigationController 即导航控制器是一个用于控制视图页面切换的一个类</p><blockquote><p>UINavigationController(导航控制器)是一个容器控制器, 其内部展示着多个UIViewController(视图控制器)的内容, 我们可以通过UINavigationController的view属性获取到其自身的视图, 在该视图上有一个位于界面顶部的UINavigationBar(导航栏)和位于界面底部的默认隐藏的UIToolbar(工具栏), 以及一个位于界面中间部分的UIViewController的view<br>作者：蚊香酱<br>链接：<a href="https://juejin.cn/post/6844903463868956679">https://juejin.cn/post/6844903463868956679</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><img src="https://user-gold-cdn.xitu.io/2017/2/16/d2ce61d3cefb842b258892a326174054?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" /><p><img src="https://user-gold-cdn.xitu.io/2017/2/16/0ce5a3e61c83a23812c2765421534aff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="pushViewController-animated"><a href="#pushViewController-animated" class="headerlink" title="pushViewController:animated:"></a>pushViewController:animated:</h4><h4 id="popViewControllerAnimated"><a href="#popViewControllerAnimated" class="headerlink" title="popViewControllerAnimated:"></a>popViewControllerAnimated:</h4>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/blog/21992.html"/>
    <url>/blog/21992.html</url>
    
    <content type="html"><![CDATA[<p>堆可以看做是完全二叉树的数组表示</p><p>常见的堆的用法有：</p><ul><li>堆排序</li><li>找出最大(最小)的k个数字</li><li>让代码看起来更<span><ruby>高<rp><del></rp><rt>牛</rt>效<rt>逼</rt><rp></del></rp></ruby></span></li></ul><p>堆分为：大根堆和小根堆</p><p>既然完全二叉树那么父节点，左子树节点和右子树节点在数组坐标上分别为<code>i</code>，<code>i*2</code>，<code>i*2+1</code>, 在c++或其他的int是整除的语言中，对于一个点<code>j</code>, 它的父节点为<code>j / 2</code></p><p>[toc]</p><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><p>父节点的值都大于子节点的值</p><p><img src="https://upload-images.jianshu.io/upload_images/4064751-14a6cde25bdff968.png" alt="img"></p><h5 id="构建大根堆-插入新元素"><a href="#构建大根堆-插入新元素" class="headerlink" title="构建大根堆/插入新元素"></a>构建大根堆/插入新元素</h5><p>给定一个数组构造大根堆：</p><ul><li><p>若只有一个点，那点的序列就是大根堆</p></li><li><p>若数据&gt;=2时就需要进行调整，从插入的那个小子树开始调整使其成为大根堆，然后再逐步向上调整小子树根节点所在的子树</p></li><li><p>以[1, 2, 3, 4]为例子</p><p>①、插入1</p><p>②、插入2，<code>[1, 2]</code></p><p>可以看到在把2插入末尾时(此时为左子树)，不满足大根堆要求，因此进行调整也就是<code>swap(root, max(left, right))</code>之后变为</p><p><mark><code>[2, 1]</code></mark></p><p><img src="https://ftp.bmp.ovh/imgs/2021/06/e62dec6960c015d4.png"></p><p>③、插入3，<code>[2, 1, 3]</code>, 满足</p><p>④、插入4，<code>[2, 1, 3, 4]</code> 不满足</p><p><img src="https://i.bmp.ovh/imgs/2021/06/000f9241f522379c.png"></p></li></ul><p>总结：在构建大根堆时需要层层调整，简单来说就是插入一个新元素时，若其大于根节点，则和根节点交换，交换之后需要基于这个新的根节点再递归向上遍历根节点，而这个过程也叫做<mark>向上调整</mark></p><p><strong>代码实现</strong></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void insert(vector&lt;int&gt;&amp;list, int x) &#123;    list.push_back(x);    shiftUp(list, list.size() - 1);&#125;void shiftUp(vector&lt;int&gt;&amp;list, int i) &#123;    int root &#x3D; i &#x2F; 2; &#x2F;&#x2F; 整除    if(root &#x3D;&#x3D; i) &#123;        return; &#x2F;&#x2F; 递归出口，最后的根节点    &#125;    if(list[root] &lt; list[i]) &#123;        swap(list[root], list[i]);        shiftUp(list, root);    &#125;&#125;</code></pre></div><p><strong>原地创建</strong></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void createMaxHead(vector&lt;int&gt;&amp; list) &#123;    if (list.size() &lt;&#x3D; 1) &#123;        return;    &#125;    &#x2F;&#x2F; 模拟空白数组逐个插入元素，那么原地构建相当于从头遍历每个元素作为插入的最后一个元素然后向上调整    for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;        shiftUp(list, i);    &#125;&#125;</code></pre></div><h5 id="取出元素"><a href="#取出元素" class="headerlink" title="取出元素"></a>取出元素</h5><p>在大根堆中，根元素为最大的元素，当删除根元素后，结构上也需要进行调整以满足大根堆</p><p>以上例构建的大根堆为例</p><p><img src="https://ftp.bmp.ovh/imgs/2021/06/7a39996a1b7c154f.png"></p><p>① 将最后一个元素补上根节点的位置</p><p>② 将这个新的根节点和较大的左右节点交换，即<code>swap(root, max(left, right))</code></p><p>③交换往后，需要递归的调整构建以此节点为根节点的小子树，而这个过程称为<mark>向下调整</mark></p><p><strong>代码实现</strong></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int remove(vector&lt;int&gt;&amp;list) &#123;    list.push_back(x);    shiftUp(list, list.size() - 1);&#125;void shiftDown(vector&lt;int&gt;&amp;list, int i) &#123;    int left &#x3D; i * 2;    int right &#x3D; i * 2 + 1;    int max &#x3D; i; &#x2F;&#x2F; 初始时将当前点作为最大点    if (left &lt; list.size() &amp;&amp; list[left] &gt; list[max]) &#123;        max &#x3D; left;    &#125;    if (right &lt; list.size() &amp;&amp; list[right] &gt; list[max]) &#123;        max &#x3D; right;    &#125;    if (max !&#x3D; i) &#123;        swap(list[i], list[max]);        shiftDown(list, max);    &#125;&#125;</code></pre></div><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>小根堆就是父元素小于父子节点的树，在实现上和大根堆差不多，只是相关比较相反即可</p><h5 id="构建小根堆-插入元素"><a href="#构建小根堆-插入元素" class="headerlink" title="构建小根堆/插入元素"></a>构建小根堆/插入元素</h5><p>和大根堆差不多也是需要层层调整，插入一个新元素时，若其<font color=red>小于</font>根节点，则和根节点交换，交换之后需要基于这个新的根节点再递归向上遍历根节点，而这个过程也叫做<mark>向上调整</mark></p><p><strong>代码实现</strong></p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void insert(vector&lt;int&gt;&amp;list, int x) &#123;    list.push_back(x);    shiftUp(list, list.size() - 1);&#125;void shiftUp(vector&lt;int&gt;&amp;list, int i) &#123;    int root &#x3D; i &#x2F; 2; &#x2F;&#x2F; 整除    if(root &#x3D;&#x3D; i) &#123;        return; &#x2F;&#x2F; 递归出口，最后的根节点    &#125;    if(list[root] &gt; list[i]) &#123; &#x2F;&#x2F; 和大根堆不同的地方        swap(list[root], list[i]);        shiftUp(list, root);    &#125;&#125;</code></pre></div><p><strong>原地构建</strong></p><p>代码和大根堆一致</p><p><strong>取出元素</strong></p><p>其过程和大根堆基本一致</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int remove(vector&lt;int&gt;&amp;list) &#123;    list.push_back(x);    shiftUp(list, list.size() - 1);&#125;void shiftDown(vector&lt;int&gt;&amp;list, int i) &#123;    int left &#x3D; i * 2;    int right &#x3D; i * 2 + 1;    int min &#x3D; i; &#x2F;&#x2F; 初始时将当前点作为最大点    if (left &lt; list.size() &amp;&amp; list[left] &lt; list[min]) &#123; &#x2F;&#x2F; 相比大根堆，判断变为找最小        min &#x3D; left;    &#125;    if (right &lt; list.size() &amp;&amp; list[right] &lt; list[min]) &#123;&#x2F;&#x2F; 相比大根堆，判断变为找最小        min &#x3D; right;  &#125;  if (min !&#x3D; i) &#123;        swap(list[i], list[min]);        shiftDown(list, min);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>全排序的生成方式(未完成)</title>
    <link href="/blog/29086.html"/>
    <url>/blog/29086.html</url>
    
    <content type="html"><![CDATA[<p><code>全排序</code>：基于给定的几个元素，形成他们的所有有序序列</p><h4 id="1-字典序法"><a href="#1-字典序法" class="headerlink" title="1.字典序法"></a>1.字典序法</h4><p>字典序就是在对比两个字符串时，按位对比对应位置字符的大小，直达出现字符a != 字符b时得出两个字符串的字典序大小，其中字符a和字符b的大小依据是ascii码，同时这种大小排序也符合字典的排序所以称字典序法</p><p>通过最小字典序串<code>123456789</code>,依次生成次小的字典序列串<code>123456798</code>，直到最大序列串<code>987654321</code></p><ul><li>算法步骤</li></ul><p>设P是集合{1，2，……n-1，n}的一个全排列：P=P1, P2……Pj-1, Pj, Pj+1 ……Pn（1≤P1，P2，……，Pn≤n-1）</p><ol><li>从排列的右端开始，找出第一个比右边数字小的数字的序号j，即j=max{i|Pi&lt;Pi+1，i&gt;j}</li><li>在Pj的右边的数字中，找出所有比Pj大的数字中最小的数字Pk，即k=min{i|Pi&gt;Pj，i&gt;j}</li><li>交换Pj，Pk</li><li>再将排列右端的递减部分Pj+1Pj+2……Pn倒转，因为j右端的数字是降序，所以只需要其左边和右边的交换，直到中间，因此可以得到一个新的排列P’=P1P2……Pj-1PkPn……Pj+2Pj+1。</li></ol><p><img src="https://img-blog.csdnimg.cn/20181101133823660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhcHB5Um9ja2luZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>以上是数学过程，看起来没有树图形式好理解</p><p><img src="https://ftp.bmp.ovh/imgs/2021/06/079e6cb851b041e9.png"></p><p>通过树图理解全排序，在算法里有点dfs的意味，一个虚拟的根节点，然后分别以不同的节点作为子节点后向下遍历，当然这个遍历的节点中排除了已经遍历过的点</p><p>有点类似一串链子上的珠子，单独拎起某个后形成一层树网，然后子节点在基于去除父节点的珠链，拉起自身形成下一层珠链</p><h3 id="2-插入法"><a href="#2-插入法" class="headerlink" title="2.插入法"></a>2.插入法</h3><blockquote><p>如果已知n-1个元素的排列，将n插入到排列的不同位置，就得到了n个元素的排列。用这种方法可以产生出任意n个元素的排列。这个方法有一个缺点：为了产生n个元素的排列，我们必须知道并存储所有n-1个元素的排列，然后才能产生出所有n阶排列。</p></blockquote><p>单个元素的全排序必为自身，那么n个元素的全排序，可以看成在n-1个元素的所有排序结果中，在不同的位置插入元素n形成n个元素的全排序</p><p>这样分析后整个问题就可以划分为更小的子问题，有点递归分治的意思</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 假设有n个元素的集合，全排序集合为p(n)if count(n) &#x3D;&#x3D; 1p(n) &#x3D; &#123;n&#125;else p(n) &#x3D; n insert p(n-1) &#x2F;&#x2F;把元素n插入p(n-1)序列中的每一个位置</code></pre></div><h3 id="3-邻位对换法"><a href="#3-邻位对换法" class="headerlink" title="3.邻位对换法"></a>3.邻位对换法</h3><blockquote><p>该算法由Johnson-Trotter首先提出，是一个能快速生成全排列的算法。它的下一个全排列总是上一个全排列对换某相邻两位得到的。</p></blockquote><ul><li>算法步骤[<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%A8%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95&action=edit&section=7">编辑</a>]</li></ul><ol><li>初始化n个元素的排列为123……n，并规定其元素的方向都是向左的，元素的方向用一个数组b来表示，当b[i]=0，表示第i个元素的方向向左，当b[i]=1时表示第i个元素的方向向右。</li><li>在排列中找出排列中所有处于活动状态的元素中最大的一个。</li><li>将它与它所指向相邻元素交换。</li><li>把排列中大于上面找出的处在活动状态的最大元素大的其他元素的方向倒转。</li></ol><blockquote><p>在此之前我们实现全排列本质上都是采用单向交换的思路，当交换到末端便要回溯至上一层面，如果我们采用双向的交换，便可以不断地交换下去，于是产生了邻位对换法。邻位对换法在找下一个排列的方法上在很多情况下要比字典序算法要快上许多，因为每次的下一个排列只是交换两个相邻的元素，当然缺点就是到左端或者右端时要进行找最大可移动数的计算，故最终整体效率也没什么提升，所以称之为最蛋疼的全排列算法。<br>————————————————<br>版权声明：本文为CSDN博主「九日王朝」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sm9sun/article/details/77373258">https://blog.csdn.net/sm9sun/article/details/77373258</a></p></blockquote><p>🌰</p><p>123的序列进行模拟</p><ol><li>初始<ul><li><code>在排列中找出排列中所有处于活动状态的元素中最大的一个</code>, 活动状态值一个元素比它指向的活动方向的元素大，此时1，2，3都满足可活动要求，而3是可活动的最大元素</li></ul></li></ol><p><mark><ruby><br>1 <rt>←</rt>2<rt>←</rt>3<rt>←</rt><br></ruby></mark></p><p>2.根据<mark>在排列中找出排列中所有处于活动状态的元素中最大的一个。将它与它所指向相邻元素交换</mark></p><p><mark><ruby><br>1 <rt>←</rt>3<rt>←</rt>2<rt>←</rt><br></ruby></mark></p><ol start="3"><li>把排列中大于上面找出的处在活动状态的最大元素大的其他元素的方向倒转</li></ol><ul><li>因为此时没有比3大的元素所以没有元素进行方向翻转</li></ul><p>按1、2、3的流程继续指向，直到3移动到最左边<mark><ruby><br>3 <rt>←</rt>1<rt>←</rt>2<rt>←</rt><br></ruby></mark></p><ol start="4"><li>此时按照算法流程处于活动状态的最大一个元素为2</li></ol><ul><li>交换<ul><li><mark><ruby><br>3 <rt>←</rt>2<rt>←</rt>1<rt>←</rt><br></ruby></mark></li></ul></li><li><code>把排列中大于上面找出的处在活动状态的最大元素大的其他元素的方向倒转。</code><ul><li><ruby>3 <rt>→</rt>2<rt>←</rt>1<rt>←</rt></ruby></li></ul></li></ul><ol start="5"><li><p>可以看到此时可活动的元素有3和2，而3为最大元素因此</p><ul><li>交换<ul><li><mark><ruby><br>2 <rt>←</rt>3<rt>→</rt>1<rt>←</rt><br></ruby></mark></li></ul></li></ul></li></ol><ul><li>反转</li><li><ul><li>无目标元素</li></ul></li></ul><ol start="6"><li>此时最大的可活动元素依旧为3</li></ol><ul><li><mark><ruby><br>2 <rt>←</rt>1<rt>←</rt>3<rt>→</rt><br></ruby></mark></li></ul><p>最后可以发现字符串中已经没有可活动的元素了，此时也结束了全排序的遍历</p><h3 id="4-递增进位制法"><a href="#4-递增进位制法" class="headerlink" title="4.递增进位制法"></a>4.递增进位制法</h3><blockquote><p>这个算法是基于序列的递增进位制数<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95#cite_note-auto-3">[3]</a>。递增进位制数是指数字的进制随着位数的递增而递增。一般情况下，数字最右边的进制是2，次右边的进制是3，以此类推。n位递增进位制数一共包含n!个数字，所以它可以与全排列生成算法结合在一起。</p></blockquote><h3 id="5-递减进位制法"><a href="#5-递减进位制法" class="headerlink" title="5.递减进位制法"></a>5.递减进位制法</h3><blockquote><p>该方法与递增进位制法的原理相似，不同的是它定义的“递减进位制数”是数字的进制随着位数的递增而递减。这种进制一般最左边的进制是2，次左边的进制是3。其余原理与递增进位制法基本相同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>夯实基础-HTML/CSS</title>
    <link href="/blog/26828.html"/>
    <url>/blog/26828.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>HTML不是一门编程语言，而是一种用于定义内容结构的<em>标记语言</em>。</strong></p><p>HTML 由一系列的<strong>元素</strong>组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作</p><ul><li><p>空元素</p></li><li><p>```html</p><img src="images/firefox-icon.png" alt="测试图片">// 本元素包含两个属性，但是并没有 </img> 结束标签，元素里也没有内容。这是因为图像元素不需要通过内容来产生效果，它的作用是向其所在的位置嵌入一个图像。<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">- &#96;&lt;!DOCTYPE html&gt;&#96; — 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991&#x2F;92 年）之时，&#96;DOCTYPE&#96; 用来链接一些 HTML 编写守则，比如自动查错之类。&#96;DOCTYPE&#96; 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。- &#96;&#96;&#96;html  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; — 该元素指定文档使用 UTF-8 字符编码 </code></pre></div></li><li><p> <code>&lt;ul&gt;</code>-<strong>无序列表（Unordered List）</strong></p></li><li><p><code>&lt;ol&gt;</code>-<strong>有序列表（Ordered List)</strong></p></li><li><p>```html<br>HTML中，除了<img><input><link><hr><video><audio>等标签，其它标签是不能自动闭合的</p><script>和</script>必须分开，否则会导致javascript代码无法执行<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">- 语义类标签，它们的特点是视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义，比如大家会经常见到的 section、nav、p，这些都是语义类的标签。- &#96;&#96;&#96;html  &#x2F;&#x2F; &lt;rb&gt; &lt;rt&gt; &lt;rp&gt;, &lt;rb&gt; - 下方内容主体， &lt;rt&gt; - 上方标注内容 &lt;rp&gt; - 当浏览器不兼容时备选显示内容  &lt;ruby&gt;      &lt;rb&gt;注释&lt;&#x2F;rb&gt;      &lt;rt&gt;zhushi&lt;&#x2F;rt&gt;      &lt;rp&gt;备选&lt;&#x2F;rp&gt;  &lt;&#x2F;ruby&gt;        &lt;ruby&gt;    汉 &lt;rp&gt;(&lt;&#x2F;rp&gt;&lt;rt&gt;Han&lt;&#x2F;rt&gt;&lt;rp&gt;)&lt;&#x2F;rp&gt;    字 &lt;rp&gt;(&lt;&#x2F;rp&gt;&lt;rt&gt;zi&lt;&#x2F;rt&gt;&lt;rp&gt;)&lt;&#x2F;rp&gt;  &lt;&#x2F;ruby&gt;</code></pre></div></li><li><ruby>    <rb>注释</rb>    <rt>zhushi</rt>    <rp>备选</rp></ruby></li><li><ruby>  汉 <rp>(</rp><rt>Han</rt><rp>)</rp>  字 <rp>(</rp><rt>zi</rt><rp>)</rp></ruby></li></ul><p>abbr 标签表示缩写</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;abbr title&#x3D;&quot;World Wide Web&quot;&gt;WWW&lt;&#x2F;abbr&gt;.</code></pre></div><p><abbr title="World Wide Web">WWW</abbr>.</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;hr&gt;&lt;&#x2F;hr&gt;横向分割线</code></pre></div><hr></hr><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;blockquote&gt;blockquote&lt;&#x2F;blockquote&gt;&lt;q&gt;q&lt;&#x2F;q&gt;&lt;cite&gt;cite&lt;&#x2F;cite&gt;</code></pre></div><blockquote>blockquote</blockquote><p><q>q</q></p><p><cite>cite</cite></p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;figure&gt; &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;6&#x2F;65&#x2F;Web_Index.svg&#x2F;2560px-Web_Index.svg.png&quot; style&#x3D;&quot;width:50%; height:50%&quot; &#x2F;&gt; &lt;figcaption&gt;The NeXT Computer used by Tim Berners-Lee at CERN.&lt;&#x2F;figcaption&gt;&lt;&#x2F;figure&gt;</code></pre></div><figure> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/Web_Index.svg/2560px-Web_Index.svg.png" style="width:50%; height:50%" /> <figcaption>The NeXT Computer used by Tim Berners-Lee at CERN.</figcaption></figure><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;dfn&gt;Internet&lt;&#x2F;dfn&gt;定义词</code></pre></div><p><dfn>Internet</dfn></p><div class="code-wrapper"><pre><samp>GET /home.html HTTP/1.1Host: www.example.org</samp></pre></div><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;pre&gt;&lt;samp&gt;GET &#x2F;home.html HTTP&#x2F;1.1Host: www.example.org&lt;&#x2F;samp&gt;&lt;&#x2F;pre&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;code&gt;123&lt;&#x2F;code&gt;&lt;mark&gt;高亮&lt;&#x2F;mark&gt;&lt;section&gt;456&lt;&#x2F;section&gt;</code></pre></div><p><code>123</code></p><p><mark>高亮</mark></p><section>456</section><iframe class="interactive" width="100%" height="375" src="https://interactive-examples.mdn.mozilla.net/pages/tabbed/samp.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe><p><code>语义标签</code>，对seo友好，不过开发上有点困难，如果是做web网页的话可以考虑，以增加自己seo的搜索权重</p><h4 id="head中的标签"><a href="#head中的标签" class="headerlink" title="head中的标签"></a>head中的标签</h4><ul><li>title标签</li><li>base标签：历史遗留标签，它的作用是给页面上所有的 URL 相对地址提供一个基础，但可能照成js的配合困难</li></ul><p>meta 标签：在 head 中可以出现任意多个 meta 标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;meta name&#x3D;application-name content&#x3D;&quot;lsForums&quot;&gt;&lt;!--这里的 name 是一种比较自由的约定，HTTP 标准规定了一些 name 作为大家使用的共识，也鼓励大家发明自己的 name 来使用--&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot; &gt;&lt;!--从 HTML5 开始，为了简化写法，meta 标签新增了 charset 属性--&gt;&lt;!--它描述了HTML文档自身的编码形式, 建议放在head第一行，浏览器读到这个标签之前，处理的所有字符都是 ASCII 字符--&gt;</code></pre></div><p>meta的content是个复杂结构，键值对可以使用；分开</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&gt;</code></pre></div><p>这里只指定了两个属性，宽度和缩放，实际上 viewport 能控制的更多，它能表示的全部属性如下：</p><p>width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。</p><p>height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。</p><p>initial-scale：初始缩放比例。</p><p>minimum-scale：最小缩放比例。</p><p>maximum-scale：最大缩放比例。</p><p>user-scalable：是否允许用户缩放</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。它是一门样式表语言</p><ul><li>在<code>&lt;head&gt;</code>间引入<code>&lt;link href=&quot;styles/style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></li></ul><table><thead><tr><th align="left">选择器名称</th><th align="left">选择的内容</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">元素选择器（也称作标签或类型选择器）</td><td align="left">所有指定(该)类型的 HTML 元素（要考虑 HTML 或者 XML 元素的命名空间问题）</td><td align="left"><code>p</code> 选择 <code>&lt;p&gt;</code></td></tr><tr><td align="left">ID 选择器</td><td align="left">具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td><td align="left"><code>#my-id</code> 选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td></tr><tr><td align="left">类选择器</td><td align="left">具有特定类的元素（单一页面中，一个类可以有多个实例）</td><td align="left"><code>.my-class</code> 选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td></tr><tr><td align="left">属性选择器</td><td align="left">拥有特定属性的元素</td><td align="left"><code>img[src]</code> 选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code>而不是 <code>&lt;img&gt;</code></td></tr><tr><td align="left">伪（Pseudo）类选择器</td><td align="left">特定状态下的特定元素（比如鼠标指针悬停）</td><td align="left"><code>a:hover</code> 仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code>。</td></tr></tbody></table><p>svg 和 HTML 中都有 a 元素，我们若要想区分选择 svg 中的 a 和 HTML 中的 a，就必须用带命名空间的类型选择器</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">@namespace svg url(http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg);@namespace html url(http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml);svg|a &#123; stroke:blue; stroke-width:1;&#125;html|a &#123; font-size:40px&#125;</code></pre></div><p><img src="https://mdn.mozillademos.org/files/9443/box-model.png" alt="three boxes sat inside one another. From outside to in they are labelled margin, border and padding"></p><blockquote><p>CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。</p></blockquote><h4 id="CSS的-规则"><a href="#CSS的-规则" class="headerlink" title="CSS的@规则"></a>CSS的@规则</h4><p>一个 <strong>at-rule</strong> 是一个CSS 语句以at符号开头, ‘<code>@</code>‘ (<code>U+0040 COMMERCIAL AT</code>), 后跟一个标识符，并包括直到下一个分号的所有内容, ‘<code>;</code>‘ (<code>U+003B SEMICOLON</code>), 或下一个CSS块，以先到者为准。</p><p>下面是一些 @规则, 由它们的标示符指定, 每种规则都有不同的语法:</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset"><code>@charset</code></a>, 定义样式表使用的字符集.</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import"><code>@import</code></a>, 告诉 CSS 引擎引入一个外部样式表.</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。</code></pre></div></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace"><code>@namespace</code></a>, 告诉 CSS 引擎必须考虑XML命名空间。</p></li><li><p>嵌套@规则, 是嵌套语句的子集,不仅可以作为样式表里的一个语句，也可以用在条件规则组里：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"><code>@media</code></a>, 如果满足媒介查询的条件则条件规则组里的规则生效。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page"><code>@page</code></a>, 描述打印文档时布局的变化.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>, 描述将下载的外部的字体。 </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><code>@keyframes</code></a>, 描述 CSS 动画的中间步骤 . </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports"><code>@supports</code></a>, 如果满足给定条件则条件规则组里的规则生效。 </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document"><code>@document</code></a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 <em>(推延至 CSS Level 4 规范)</em></li></ul></li></ul><h4 id="CSS的普通规则Qualified-Rule"><a href="#CSS的普通规则Qualified-Rule" class="headerlink" title="CSS的普通规则Qualified Rule"></a>CSS的普通规则Qualified Rule</h4><p><font color=darkred>属性是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。</font></p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 在css的Variables 标准中，以双中划线开头的属性被当作变量，与之配合的是var函数:root &#123;  --main-color: #06c;  --accent-color: #006;&#125;&#x2F;* The rest of the CSS file *&#x2F;#foo h1 &#123;  color: var(--main-color);&#125;</code></pre></div><p>CSS 属性值可能是以下类型。</p><ul><li>CSS 范围的关键字：initial，unset，inherit，任何属性都可以的关键字。</li><li>字符串：比如 content 属性。</li><li>URL：使用 url() 函数的 URL 值。</li><li>整数 / 实数：比如 flex 属性。</li><li>维度：单位的整数 / 实数，比如 width 属性。</li><li>百分比：大部分维度都支持。</li><li>颜色：比如 background-color 属性。</li><li>图片：比如 background-image 属性。</li><li>2D 位置：比如 background-position 属性。</li><li>函数：来自函数的值，比如 transform 属性。</li></ul><p><strong>伪类选择器</strong></p><p>伪类选择器是一系列由 CSS 规定好的选择器，它们以冒号开头。伪类选择器有普通型和函数型两种。</p><ul><li>:root 伪类表示树的根元素</li><li>:empty 伪类表示没有子节点的元素，这里有个例外就是子节点为空白文本节点的情况。</li><li>:nth-child 和 :nth-last-child 这是两个函数型的伪类，CSS 的 An+B 语法设计的是比较复杂的</li><li><img src="https://static001.geekbang.org/resource/image/1e/a9/1ebdba2978a22c13844d108318b271a9.png" alt="img" style="zoom:80%;" /></li><li>:nth-last-child 的区别仅仅是从后往前数。</li><li>:first-child :last-child 分别表示第一个和最后一个元素</li><li>:only-child 按字面意思理解即可，选中唯一一个子元素。</li></ul><p>of-type 系列，是一个变形的语法糖，S:nth-of-type(An+B) 是:nth-child(|An+B| of S) 的另一种写法。以此类推，还有 nth-last-of-type、first-of-type、last-of-type、only-of-type</p><p><strong>复杂选择器</strong></p><p>复杂选择器是针对节点关系的选择，它规定了五种连接符号。</p><ul><li>“空格”：后代，表示选中所有符合条件的后代节点，<font color=red>包括子孙子的所有后代</font> 例如“ .a .b ”表示选中所有具有 class 为 a 的后代节点中 class 为 b 的节点。</li><li>“&gt;” ：子代，表示选中符合条件的子节点，<font color=red>第一代子元素，孙子这些都不算</font></li><li>“<del>” : 后继，表示选中所有符合条件的后继节点，<font color=red>后继节点即跟当前节点具有同一个父元素，并出现在它之后的节点</font>，<font color=blue>弟弟节点</font>，例如“ .a</del>.b ”表示选中所有具有 class 为 a 的后继中，class 为 b 的节点。</li><li>“+”：直接后继<font color=blue>(第一个弟弟节点)</font>，表示选中符合条件的直接后继节点，直接后继节点即 nextSlibling。例如 “.a+.b ”表示选中所有具有 class 为 a 的下一个 class 为 b 的节点。</li><li>“||”：列选择器，表示选中对应列中符合条件的单元格。<font color=dark>很诡异的选择器</font></li></ul><p><img src="https://image.zhangxinxu.com/image/blog/201902/table-col.png" alt="表格中的整列样式控制"></p><p><strong>css规则优先级</strong></p><p>CSS 标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。</p><ul><li>id 选择器的数目记为 a；</li><li>伪类选择器和 class 选择器的数目记为 b；</li><li>伪元素选择器和标签选择器数目记为 c；</li><li>“*” 不影响优先级。</li></ul><p>CSS 标准建议用一个足够大的进制，获取“ a-b-c ”来表示选择器优先级。</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">specificity &#x3D; base * base * a + base * b + c&#x2F;&#x2F; 其中为了避嫌base*b追上base*base*a，base需要是一个‘足够大’的正整数，目前是65536</code></pre></div><p>对于同一优先级的规则，采用<code>后面覆盖前面</code>的规则</p><p>!import &gt; 内联样式 &gt; ID选择器 &gt; 伪类 &gt; 属性选择器 &gt; 类选择器 &gt; 元素(类型)选择器 &gt; 通用选择器</p><p>伪元素的语法跟伪类相似，但是实际产生的效果是把不存在的元素硬选出来。这一点就与伪类不太一样了</p><blockquote><p> 伪类(如:first-child)的操作对象是文档树中已有的元素，而伪元素(如:first-letter)则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素</p><p>CSS3 规范中的要求使用双冒号 (::) 表示伪元素，以此来区分伪元素和伪类，比如::before 和::after 等伪元素使用双冒号 (::) ，    :hover 和:active 等伪类使用单冒号 (:)。</p></blockquote><p><img src="http://www.alloyteam.com/wp-content/uploads/2016/05/%E4%BC%AA%E7%B1%BB.png" alt="伪类"></p><p><img src="http://www.alloyteam.com/wp-content/uploads/2016/05/%E4%BC%AA%E5%85%83%E7%B4%A0.png" alt="伪元素"></p><h4 id="css中的超链接家族"><a href="#css中的超链接家族" class="headerlink" title="css中的超链接家族"></a>css中的超链接家族</h4><p><img src="https://static001.geekbang.org/resource/image/ca/51/caab7832c425b3af2b3adae747e6f551.png" alt="img"></p><p>map标签和area标签</p><p> Please select a shape: <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSSZtgg57oskmtYT9w5W_uR99u4xgRIq5osqnjWZFrt3P61K0-P1QWXrBiPNU8SJgy6Kdb1aNSpMq4&usqp=CAU" usemap="#shapes"      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star."> <map name="shapes">  <area shape=rect coords="50,50,100,100"> <!-- the hole in the red box -->      <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">  <area shape=circle coords="200,75,50" href="green.html" alt="Green circle.">  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle.">  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"        href="yellow.html" alt="Yellow star."> </map></p><p>简单来说就是一个img标签可以指定一个map(使用usemap)，然后在<code>&lt;map&gt;</code>标签中定义若干个<code>&lt;area&gt;</code>，而<code>&lt;area&gt;</code>指定img中的某个区域的点击跳转事件，某种意义上弥补了a标签的不足，因为a标签不能嵌套，area可以，同时map下的area不一定要是第一个子元素可以说孙子节点</p><blockquote><p>如果<code>&lt;area&gt;</code>要想和图片热点关联，祖先元素<code>&lt;map&gt;</code>是不可缺少的，但是不一定非得直接父子关系。<code>&lt;map&gt;</code>和<code>&lt;area&gt;</code>之间再嵌套个<code>&lt;div&gt;</code>什么的功能也是正常的</p><p><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/</a></p></blockquote><blockquote><p>补充a标签的target </p></blockquote><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">_blank</td><td align="left">在新窗口中打开被链接文档。</td></tr><tr><td align="left">_self</td><td align="left">在被点击时的同一框架中打开被链接文档（默认）。</td></tr><tr><td align="left">_parent</td><td align="left">在父框架中打开被链接文档。</td></tr><tr><td align="left">_top</td><td align="left">在窗口主体中打开被链接文档。</td></tr></tbody></table><p>grid网格布局</p><p>flex布局可以看成一维布局，而grid就是二维布局</p><p>picture 元素可以根据屏幕的条件为其中的 img 元素提供不同的源</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;picture&gt;  &lt;source srcset&#x3D;&quot;image-wide.png&quot; media&#x3D;&quot;(min-width: 600px)&quot;&gt;  &lt;img src&#x3D;&quot;image-narrow.png&quot;&gt;&lt;&#x2F;picture&gt;</code></pre></div><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p>animation的基本用法</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">@keyframes mykf&#123;  from &#123;background: red;&#125;  to &#123;background: yellow;&#125;&#125;div&#123;    animation:mykf 5s infinite;&#125;</code></pre></div><h3 id="css三大基本问题"><a href="#css三大基本问题" class="headerlink" title="css三大基本问题"></a>css三大基本问题</h3><ul><li>垂直居中问题</li><li>两列等高问题</li><li>自适应宽问题</li></ul><p>flex的align-items: stretch;</p><div><iframe class="interactive" height="390" src="https://interactive-examples.mdn.mozilla.net/pages/css/align-items.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe></div><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>模拟抛物线小球</p><style>    .ball {        width:10px;        height:10px;        background-color:black;        border-radius:5px;        position:absolute;        left:0;        top:0;        transform:translateY(180px);</style><script>    function generateCubicBezier (v, g, t){    var a = v / g;    var b = t + v / g;    return [[(a / 3 + (a + b) / 3 - a) / (b - a), (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)],        [(b / 3 + (a + b) / 3 - a) / (b - a), (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)]];}function createBall() {  var ball = document.createElement("div");  var t = Number(document.getElementById("t").value);  var vx = Number(document.getElementById("vx").value);  var vy = Number(document.getElementById("vy").value);  var g = Number(document.getElementById("g").value);  ball.className = "ball";  document.body.appendChild(ball)  ball.style.transition = `left linear ${t}s, top cubic-bezier(${generateCubicBezier(vy, g, t)}) ${t}s`;  setTimeout(function(){     ball.style.left = `${vx * t}px`;     ball.style.top = `${vy * t + 0.5 * g * t * t}px`;   }, 100);  setTimeout(function(){ document.body.removeChild(ball); }, t * 1000);}</script><body>    <label>运动时间：<input value="3.6" type="number" id="t" />s</label><br/>  <label>初速度：<input value="-21" type="number" id="vy" /> px/s</label><br/>  <label>水平速度：<input value="21" type="number" id="vx" /> px/s</label><br/>  <label>重力：<input value="10" type="number" id="g" /> px/s²</label><br/>  <button onclick="createBall()">来一个球</button></body><p>用 JavaScript 来实现一个 transition 函数，用它来跟 CSS 的 transition 来做一下对比</p><h3 id="css颜色"><a href="#css颜色" class="headerlink" title="css颜色"></a>css颜色</h3><p>background-image这样的属性，可以设为渐变</p><p>线性渐变的写法是：</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">linear-gradient(direction, color-stop1, color-stop2, ...);</code></pre></div><p>真正的金色</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">background: linear-gradient(45deg, gold 10%, yellow 50%, gold 90%); </code></pre></div><div id="grad1" style="height: 20px; width: 20px;background: linear-gradient(45deg, gold 10%, yellow 50%, gold 90%); "></div><p><img src="https://static001.geekbang.org/resource/image/0f/ac/0f6f4cc6d564df9986e0108cb8a427ac.jpg" alt="img"></p><p>把鸟换成红色</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  &lt;title&gt;Document&lt;&#x2F;title&gt;  &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;    .bird &#123;      width: 400px;      height: calc(1440 * 400 &#x2F; 1920 * 1px);    &#125;    canvas.bird &#123;      background: #ccc;    &#125;  &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;img id&#x3D;&quot;img&quot; class&#x3D;&quot;bird&quot; src&#x3D;&quot;.&#x2F;bird.jpg&quot;&gt;  &lt;canvas id&#x3D;&quot;canvas&quot; width&#x3D;&quot;1920&quot; height&#x3D;&quot;1440&quot; class&#x3D;&quot;bird&quot;&gt;&lt;&#x2F;canvas&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;    let canvas &#x3D; document.getElementById(&#39;canvas&#39;)    let ctx &#x3D; canvas.getContext(&#39;2d&#39;)    let img &#x3D; document.getElementById(&#39;img&#39;)    img.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;      ctx.drawImage(img, 0, 0)      let imageData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height)      let data &#x3D; imageData.data      for (let i &#x3D; 0; i &lt; data.length; i +&#x3D; 4) &#123;        if (isBird(data, i, canvas.width, canvas.height)) &#123;          ;[data[i], data[i + 1]] &#x3D; [data[i + 1] * 1.2, data[i]]        &#125;      &#125;      ctx.putImageData(imageData, 0, 0)    &#125;)    function isBird (data, i, width, height) &#123;      let r &#x3D; data[i]      let g &#x3D; data[i + 1]      let b &#x3D; data[i + 2]      let [h, s, l] &#x3D; rgb2hsl(r, g, b)      return h &lt; 200 &amp;&amp; h &gt; 80 &amp;&amp; s &gt; 0.23 &amp;&amp; l &lt; 0.84    &#125;    function rgb2hsl (r, g, b) &#123;      let r1 &#x3D; r &#x2F; 255      let g1 &#x3D; g &#x2F; 255      let b1 &#x3D; b &#x2F; 255      let min &#x3D; Math.min(r1, g1, b1)      let max &#x3D; Math.max(r1, g1, b1)      let l &#x3D; (min + max) &#x2F; 2      let s      let h      if (l &lt; 0.5) &#123;        s &#x3D; (max - min) &#x2F; (max + min)      &#125; else &#123;        s &#x3D; (max - min) &#x2F; (2 - max - min)      &#125;      if (max &#x3D;&#x3D;&#x3D; r1) &#123;        h &#x3D; (r1 - b1) &#x2F; (max - min)      &#125; else if (max &#x3D;&#x3D;&#x3D; g1) &#123;        h &#x3D; 2 + (b1 - r1) &#x2F; (max - min)      &#125; else if (max &#x3D;&#x3D;&#x3D; b1) &#123;        h &#x3D; 4 + (r1 - g1) &#x2F; (max - min)      &#125;      h *&#x3D; 60      while (h &lt; 0) &#123;        h +&#x3D; 360      &#125;      return [h, s, l]    &#125;  &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>或</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">filter: hue-rotate(240deg); &#x2F;&#x2F; 根据HSL色环，绿色在120deg的位置，要变成红色，把色相顺时针旋转240deg或者逆时针120deg即可</code></pre></div><p>filter滤镜属性，对元素进行效果叠加，有blur等方法，其中<code>hue-rotate</code>为色调旋转，可以使用<code>hue-rotate(angle)</code>angle为对应旋转的角度</p><h3 id="ARIA可访问性"><a href="#ARIA可访问性" class="headerlink" title="ARIA可访问性"></a>ARIA可访问性</h3><p>ARIA不会影响web的外观，但可以添加role使得屏幕阅读器使用者了解该内容的作用，在弹出的消息元素上添加role=alert就可以使得阅读器播报该内容</p><blockquote><p>但<strong>ARIA永远无法替代语义化HTML标签</strong>。</p></blockquote><h2 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h2><h3 id="建议用void-0替代undefined"><a href="#建议用void-0替代undefined" class="headerlink" title="建议用void 0替代undefined"></a>建议用void 0替代undefined</h3><p>因为undefined目前是一个全局变量而非关键字， 所以可能被串改</p><h3 id="js中的number精度"><a href="#js中的number精度" class="headerlink" title="js中的number精度"></a>js中的number精度</h3><blockquote><p> 表达范围 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数</p></blockquote><h3 id="正确比较0-1-0-2-等于0-3"><a href="#正确比较0-1-0-2-等于0-3" class="headerlink" title="正确比较0.1 + 0.2 等于0.3"></a>正确比较0.1 + 0.2 等于0.3</h3><p>由于受number的精度影响在js中以下代码是不成立的</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log( 0.1 + 0.2 &#x3D;&#x3D; 0.3);</code></pre></div><p>正确比较方式为</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;&#x3D; Number.EPSILON);</code></pre></div><p>通过js提供的最小精度来判断</p><h3 id="js数据类型上的装箱操作"><a href="#js数据类型上的装箱操作" class="headerlink" title="js数据类型上的装箱操作"></a>js数据类型上的装箱操作</h3><p>在js中可以直接在一些基本数据类型上使用对象方法，如string基本数据类型，可以使用.charAt()这些在String对象类型上的方法，是因为<code>.</code>运算符提供了装箱操作，会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法</p><h3 id="js的类型转换"><a href="#js的类型转换" class="headerlink" title="js的类型转换"></a>js的类型转换</h3><p>可以通过基本数据类型对应的类来执行装箱装换</p><p>强制生成Symbol对象</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var symbolObject &#x3D; (function()&#123; return this; &#125;).call(Symbol(&quot;a&quot;));console.log(typeof symbolObject); &#x2F;&#x2F;objectconsole.log(symbolObject instanceof Symbol); &#x2F;&#x2F;trueconsole.log(symbolObject.constructor &#x3D;&#x3D; Symbol); &#x2F;&#x2F;true</code></pre></div><p>使用Object函数</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var symbolObject &#x3D; Object(Symbol(&quot;a&quot;));console.log(typeof symbolObject); &#x2F;&#x2F;objectconsole.log(symbolObject instanceof Symbol); &#x2F;&#x2F;trueconsole.log(symbolObject.constructor &#x3D;&#x3D; Symbol); &#x2F;&#x2F;true</code></pre></div><p>拆箱装换</p><blockquote><p>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">@@toPrimitive Symbol</a></p><h3 id="基于对象的js和面向对象的其他"><a href="#基于对象的js和面向对象的其他" class="headerlink" title="基于对象的js和面向对象的其他"></a>基于对象的js和面向对象的其他</h3><blockquote><p>JavaScript 标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”</p></blockquote><p>对象的基本特征：标识性、状态和行为</p><blockquote><p>JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p></blockquote><blockquote><p>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。</p></blockquote><blockquote><p>JavaScript 用一组特征（attribute）来描述属性（property）</p></blockquote><p>这一点类同OC中的@property中使用的特性，即对一个属性本身的特点进行规定</p><p>数据属性的四个特性</p><ul><li>value：就是属性的值。</li><li>writable：决定属性能否被赋值。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值</li></ul><p>访问器（getter/setter）属性的特性</p><ul><li>getter：函数或 undefined，在取属性值时被调用。</li><li>setter：函数或 undefined，在设置属性值时被调用。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取特性getOwnPropertyDescriptor    var o &#x3D; &#123; a: 1 &#125;;    o.b &#x3D; 2;    &#x2F;&#x2F;a和b皆为数据属性    Object.getOwnPropertyDescriptor(o,&quot;a&quot;) &#x2F;&#x2F; &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;    Object.getOwnPropertyDescriptor(o,&quot;b&quot;) &#x2F;&#x2F; &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;&#x2F;&#x2F; 设置特性defineProperty    var o &#x3D; &#123; a: 1 &#125;;    Object.defineProperty(o, &quot;b&quot;, &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;);    &#x2F;&#x2F;a和b都是数据属性，但特征值变化了    Object.getOwnPropertyDescriptor(o,&quot;a&quot;); &#x2F;&#x2F; &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;    Object.getOwnPropertyDescriptor(o,&quot;b&quot;); &#x2F;&#x2F; &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;    o.b &#x3D; 3;    console.log(o.b); &#x2F;&#x2F; 2</code></pre></div><p>==对象的property属性和私有字段[[property]]不是一个概念==</p><p>new 运算接受一个构造器和一组调用参数，实际上做了几件事：</p><ol><li>以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；</li><li>将 this 和调用参数传给构造器，执行；</li><li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li></ol><div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定[[prototype]]的方法（当时的 mozilla 提供了私有属性 __proto__，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 polyfill，见以下代码：</div><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object.create &#x3D; function(prototype)&#123;    var cls &#x3D; function()&#123;&#125;    cls.prototype &#x3D; prototype;    return new cls;&#125;</code></pre></div><h3 id="js的对象分类"><a href="#js的对象分类" class="headerlink" title="js的对象分类"></a>js的对象分类</h3><p>js的对象可以分为几类</p><ul><li>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</li></ul><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">比如浏览器环境下window对象下又一些属性一部分来自js语言，一部分来自浏览器环境，js标准中规定了全局对象属性，W3C的各种标准中规定了Window对象的其他属性</code></pre></div><ul><li><p>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。</p><ul><li><p>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">它们通常扮演类似基础库的角色</code></pre></div><p>ECMA标准中提供的<a href="https://262.ecma-international.org/9.0/#sec-well-known-intrinsic-objects">固有对象表</a>, 但并不完整</p></li><li><p>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</p><p><img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" alt="img"></p><p>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。</p><blockquote><p>函数对象的定义是：具有[[call]]私有字段的对象，构造器对象的定义是：具有私有字段[[construct]]的对象。</p></blockquote></li><li><p>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</p></li></ul></li></ul><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function f()&#123;    return 1;&#125;var v &#x3D; f(); &#x2F;&#x2F;把f作为函数调用var o &#x3D; new f(); &#x2F;&#x2F;把f作为构造器调用</code></pre></div><p>我们大致可以认为，它们[[construct]]的执行过程如下：</p><ul><li>以 Object.prototype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的[[call]]；</li><li>如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li></ul><p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function cls()&#123;    this.a &#x3D; 100;    return &#123;        getValue:() &#x3D;&gt; this.a    &#125;&#125;var o &#x3D; new cls;o.getValue(); &#x2F;&#x2F;100&#x2F;&#x2F;a在外面永远无法访问到</code></pre></div><h3 id="promise和setInterval"><a href="#promise和setInterval" class="headerlink" title="promise和setInterval"></a>promise和setInterval</h3><blockquote><p>采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务</p></blockquote><blockquote><p>有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p></blockquote><p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：</p><img src="https://static001.geekbang.org/resource/image/16/65/16f70a9a51a65d5302166b0d78414d65.jpg" alt="img" style="zoom:30%;" /><blockquote><p>微任务总会在下一个宏任务之前执行，在本身所属的宏任务结束后立即执行</p><p>执行主线程宏任务(同步代码) -&gt; 执行并清空微任务队列 -&gt; 执行下一个宏任务</p></blockquote><p>Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。因此Promise.then的输出会在setTimeout前面</p><p>==微任务优先==</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 尽管c2是在d之后才添加的，但还是在d前输出，说明了微任务优先    setTimeout(()&#x3D;&gt;console.log(&quot;d&quot;), 0)    var r &#x3D; new Promise(function(resolve, reject)&#123;        resolve()    &#125;);    r.then(() &#x3D;&gt; &#123;         var begin &#x3D; Date.now();        while(Date.now() - begin &lt; 1000);        console.log(&quot;c1&quot;)         new Promise(function(resolve, reject)&#123;            resolve()        &#125;).then(() &#x3D;&gt; console.log(&quot;c2&quot;))    &#125;);    &#x2F;&#x2F; c1    &#x2F;&#x2F; c2    &#x2F;&#x2F; d</code></pre></div><div style='border-left: 5px solid #0d93ea; padding: 10px;background: #eee; color: #555'>实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色</div><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function sleep(duration)&#123;    return new Promise(function(resolve)&#123;        setTimeout(resolve, duration);    &#125;)&#125;async function changeColor(duration,color)&#123;    document.getElementById(&quot;traffic-light&quot;).style.background &#x3D; color;    await sleep(duration);&#125;async function main()&#123;    while(true)&#123;        await changeColor(3000,&quot;green&quot;);        await changeColor(1000, &quot;yellow&quot;);        await changeColor(2000, &quot;red&quot;);    &#125;&#125;main()</code></pre></div><h3 id="闭包和执行上下文"><a href="#闭包和执行上下文" class="headerlink" title="闭包和执行上下文"></a>闭包和执行上下文</h3><img src="https://static001.geekbang.org/resource/image/68/52/68f50c00d475a7d6d8c7eef6a91b2152.png" alt="img" style="zoom:70%;" /><blockquote><p>闭包其实只是一个绑定了执行环境的函数</p></blockquote><blockquote><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。 在JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p></blockquote><p>古典的闭包定义中，闭包包含两个部分</p><p><a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">闭包</a></p><ul><li><p>环境部分</p><ul><li><p>环境</p><p>函数的词法环境（执行上下文的一部分）</p></li><li><p>标识符列表</p><p>函数中用到的未声明的变量</p></li></ul></li><li><p>表达式部分: 函数体</p></li></ul><blockquote><p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。</p></blockquote><p>ES2018中的Realms组成</p><ol><li>a set of intrinsic objects(一组内置对象)</li><li>global environment （一个全局环境）</li><li>code （在上面这个全局环境中加载的所有代码）</li><li>state and resources （状态和资源）</li></ol><blockquote><p>对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var iframe &#x3D; document.createElement(&#39;iframe&#39;)document.documentElement.appendChild(iframe)iframe.src&#x3D;&quot;javascript:var b &#x3D; &#123;&#125;;&quot;var b1 &#x3D; iframe.contentWindow.b;var b2 &#x3D; &#123;&#125;;console.log(typeof b1, typeof b2); &#x2F;&#x2F;object objectconsole.log(b1 instanceof Object, b2 instanceof Object); &#x2F;&#x2F;false true</code></pre></div><h3 id="js内的函数种类"><a href="#js内的函数种类" class="headerlink" title="js内的函数种类"></a>js内的函数种类</h3><ul><li><p>function声明的函数</p></li><li><p>箭头函数</p></li><li><p>生成器函数：用 function * 定义的函数</p></li><li><p>class内自定义的函数</p></li><li><p>class内自带的函数，如constructor</p></li><li><p>异步函数</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function foo()&#123;    &#x2F;&#x2F; code&#125;const foo &#x3D; async () &#x3D;&gt; &#123;    &#x2F;&#x2F; code&#125;async function foo*()&#123;    &#x2F;&#x2F; code&#125;</code></pre></div></li></ul><p>当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。</p><p><strong>关于var和funtion的变量提升</strong></p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(a)   &#x2F;&#x2F;undefinedvar a&#x3D;&#39;我是谁&#39;console.log(a)   &#x2F;&#x2F;&#39;我是谁&#39;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 实际执行过程相当于var a;console.log(a);a&#x3D;&#39;我是谁&#39;console.log(a)</code></pre></div><p>JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：</p><img src="https://static001.geekbang.org/resource/image/e8/31/e8d8e96c983a832eb646d6c17ff3df31.jpg" alt="img" style="zoom:70%;" /><p>当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]]私有属性。</p><p>[[thisMode]] 私有属性有三个取值。</p><ul><li>lexical：表示从上下文中找 this，这对应了箭头函数。</li><li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li><li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li></ul><p>call apple bind对于this的修改</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function foo(a, b, c)&#123;    console.log(this);    console.log(a, b, c);&#125;foo.call(&#123;&#125;, 1, 2, 3);foo.apply(&#123;&#125;, [1, 2, 3]);&#x2F;&#x2F; bind生成一个绑定this的函数foo.bind(&#123;&#125;, 1, 2, 3)();</code></pre></div><p><font color=blue>但是他们都无法改变箭头函数的this指向</font></p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var o &#x3D; &#123;  a: 1&#125;;this.a &#x3D; 2;(() &#x3D;&gt; &#123;console.log(this.a)&#125;).call(o);(function () &#123;console.log(this.a)&#125;).call(o);&#x2F;&#x2F; 2&#x2F;&#x2F; 1</code></pre></div><h3 id="Completion-Record"><a href="#Completion-Record" class="headerlink" title="Completion Record"></a>Completion Record</h3><p>Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p><ul><li>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</li><li>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</li><li>[[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。</li></ul><p>语句的分类</p><img src="https://static001.geekbang.org/resource/image/98/d5/98ce53be306344c018cddd6c083392d5.jpg" alt="img" style="zoom:60%;" /><p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。</p><p>这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。具体表现在chrom的调试器中<code>var a = 1</code>和<code>a = 1</code>的输出是不同的，前者属于声明式语句，后者为表达式</p><p>在try/catch语句中finally一点会执行，即使在try/catch中进行了return操作，不过若finally中也进行了return操作则会覆盖</p><p>关于</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">12.toString(); &#x2F;&#x2F;会报错&#x2F;&#x2F; 12.toString() 他无法分辨你是想要创建一个小数位为toString()的数 还是创建一个12 然后调用toString()这种情况, 此时可以使用(12).toString(); 或12..toString(); 来明确token</code></pre></div><h3 id="js脚本和模块"><a href="#js脚本和模块" class="headerlink" title="js脚本和模块"></a>js脚本和模块</h3><img src="https://static001.geekbang.org/resource/image/43/44/43fdb35c0300e73bb19c143431f50a44.jpg" alt="img" style="zoom:50%;" /><h3 id="js运算符的结合方向和及优先级"><a href="#js运算符的结合方向和及优先级" class="headerlink" title="js运算符的结合方向和及优先级"></a>js运算符的结合方向和及优先级</h3><table><thead><tr><th>运算符</th><th>结合性</th><th>优先级</th></tr></thead><tbody><tr><td>.、[ ]、( )</td><td>从左到右</td><td>高  ↑  |  |  |  |  |  |  |  |  |  |  | 低</td></tr><tr><td>++、–、-、！、new、typeof</td><td><mark>从右到左</mark></td><td></td></tr><tr><td>*、/、%</td><td>从左到右</td><td></td></tr><tr><td>+、-</td><td>从左到右</td><td></td></tr><tr><td>＜、＜=、＞、＞=、in、instanceof</td><td>从左到右</td><td></td></tr><tr><td><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td><td>从左到右</td><td></td></tr><tr><td>&amp;&amp;</td><td>从左到右</td><td></td></tr><tr><td>II</td><td>从左到右</td><td></td></tr><tr><td>?:</td><td><mark>从右到左</mark></td><td></td></tr><tr><td>=、*=、/=、％=、+=、-=、&amp;=、^=、!=</td><td><mark>从右到左</mark></td><td></td></tr><tr><td>,</td><td>从左到右</td><td>低</td></tr></tbody></table><hr><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script src&#x3D;&quot;scripts&#x2F;main.js&quot; defer&gt;&lt;&#x2F;script&gt;</code></pre></div><p><font color=red>值得注意的是引入外部js时不能使用自封闭标签</font></p><p>关于js中的reduce，reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></pre></div><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>function(total,currentValue, index,arr)</em></td><td align="left">必需。用于执行每个数组元素的函数。 函数参数:参数描述<em>total</em>必需。<em>初始值</em>, 或者计算结束后的返回值。<em>currentValue</em>必需。当前元素<em>currentIndex</em>可选。当前元素的索引<em>arr</em>可选。当前元素所属的数组对象。</td></tr><tr><td align="left"><em>initialValue</em></td><td align="left">可选。传递给函数的初始值</td></tr></tbody></table><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">🌰[11,22,33,44,55].reduce((total, curval, index, arr) &#x3D;&gt; &#123;console.log(total + &#39;;&#39; + curval + &#39;;&#39; + index + &#39;;&#39; + JSON.stringify(arr))&#125;);&#x2F;&#x2F; 输出11;22;1;[11,22,33,44,55]undefined;33;2;[11,22,33,44,55]undefined;44;3;[11,22,33,44,55]undefined;55;4;[11,22,33,44,55]&#x2F;&#x2F;return undefined🌰[11,22,33,44,55].reduce((total, curval, index, arr) &#x3D;&gt; &#123;console.log(total + &#39;;&#39; + curval + &#39;;&#39; + index + &#39;;&#39; + JSON.stringify(arr));return total + curval;&#125;);&#x2F;&#x2F; output11;22;1;[11,22,33,44,55]33;33;2;[11,22,33,44,55]66;44;3;[11,22,33,44,55]110;55;4;[11,22,33,44,55]&#x2F;&#x2F; return165</code></pre></div><h2 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h2><h3 id="浏览器前置知识"><a href="#浏览器前置知识" class="headerlink" title="浏览器前置知识"></a>浏览器前置知识</h3><p>从URL到网页的过程</p><ol><li><p>浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</p></li><li><p>把请求回来的 HTML 代码经过解析，构建成 DOM 树；</p></li><li><p>计算 DOM 树上的 CSS 属性；</p></li><li><p>最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；</p></li><li><p>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</p></li><li><p>合成之后，再绘制到界面上。</p></li></ol><p><img src="https://static001.geekbang.org/resource/image/63/4c/6391573a276c47a9a50ae0cbd2c5844c.jpg"></p><p>HTTP协议结构</p><img src="https://static001.geekbang.org/resource/image/3d/a1/3db5e0f362bc276b83c7564430ecb0a1.jpg" style="zoom:67%;" /><p>HTTP的一些状态码</p><ul><li><p>1xx：临时回应，表示客户端请继续。</p></li><li><p>2xx：请求成功。</p><ul><li>200：请求成功</li></ul></li><li><p>3xx: 表示请求的目标有变化，希望客户端进一步处理。</p><ul><li>301&amp;302：永久性与临时性跳转。</li><li>304：跟客户端缓存没有更新。</li></ul></li><li><p>4xx：客户端请求错误。</p><ul><li>403：无权限。</li><li>404：表示请求的页面不存在。</li><li>418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）</li></ul></li><li><p>5xx：服务端请求错误。</p><ul><li>500：服务端错误。</li><li>503：服务端暂时性错误，可以一会再试。</li></ul></li></ul><p>HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用</p><ul><li><p>支持服务端推送</p><p>传统加载网页都是浏览器先获取网页资源，然后再解析网页时增量的请求其他资源，但服务器实际是知道网页资源有哪些，使用服务器可以主动的进行推送</p></li><li><p>TCP连接复用</p><p>使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题</p></li><li><p>…</p></li></ul><h3 id="浏览器合成位图"><a href="#浏览器合成位图" class="headerlink" title="浏览器合成位图"></a>浏览器合成位图</h3><p>渲染：</p><p>将搭建好的dom树和计算好的css属性添加到位图上的过程</p><p>合成：</p><p>基于一定算法优化位图的生成方式</p><blockquote><p>合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面</p></blockquote><p>合成策略的两个极端</p><ol><li>把所有dom元素创建一个合成后的位图，这样的话当一个dom元素变化时整个位图就失效需要重绘</li><li>每个dom元素单独形成一个位图，那么每次都要重新绘制所有的位图</li></ol><p>另外还有个热区的概念</p><blockquote><p> will-change 属性，可以由业务代码来提示浏览器的合成策略</p></blockquote><p>绘制：</p><p>主要属于操作系统范畴，在计算机图形计算范畴存在”脏矩形”的算法</p><h3 id="HTML节点"><a href="#HTML节点" class="headerlink" title="HTML节点"></a>HTML节点</h3><img src="https://static001.geekbang.org/resource/image/6e/f6/6e278e450d8cc7122da3616fd18b9cf6.png" style="zoom:70%;" /><p> getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，<mark>而是一个能够动态更新的集合</mark></p><p>DOM的API大概分为以下几类</p><ul><li><p>节点：DOM 树形结构中的节点相关 API</p></li><li><p>事件：触发和监听事件相关 API</p></li><li><p>Range：操作文字范围相关 API</p></li><li><p>遍历：遍历 DOM 需要的 API</p><p>除了使用js进行遍历外还可以使用<code>NodeIterator</code> 和 <code>TreeWalker</code> 来遍历树</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; NodeIteratorvar iterator &#x3D; document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_COMMENT, null, false);var node;while(node &#x3D; iterator.nextNode())&#123;    console.log(node);&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; TreeWalkervar walker &#x3D; document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false)var node;while(node &#x3D; walker.nextNode())&#123;    if(node.tagName &#x3D;&#x3D;&#x3D; &quot;p&quot;)        node.nextSibling();    console.log(node);&#125;</code></pre></div></li></ul><h3 id="CSSOM获取一个元素的精确位置"><a href="#CSSOM获取一个元素的精确位置" class="headerlink" title="CSSOM获取一个元素的精确位置"></a>CSSOM获取一个元素的精确位置</h3><p>scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近</p><p><img src="https://static001.geekbang.org/resource/image/b6/10/b6c7281d86eb7214edf17069f95ae610.png"></p><p>绘制一个网页的所有盒轮廓到canvas上</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;  https:&#x2F;&#x2F;gist.github.com&#x2F;aimergenge&#x2F;2bcf41ac4c4d2586e48ccd5cec5c9768void function () &#123;  const canvas &#x3D; document.createElement(&#39;canvas&#39;)  canvas.width &#x3D; document.documentElement.offsetWidth  canvas.height &#x3D; document.documentElement.offsetHeight  canvas.style.position &#x3D; &#39;absolute&#39;  canvas.style.left &#x3D; &#39;0&#39;  canvas.style.right &#x3D; &#39;0&#39;  canvas.style.top &#x3D; &#39;0&#39;  canvas.style.bottom &#x3D; &#39;0&#39;  canvas.style.zIndex &#x3D; &#39;99999&#39;  document.body.appendChild(canvas)  const ctx &#x3D; canvas.getContext(&#39;2d&#39;)  draw(ctx, getAllRects())  function draw (ctx, rects) &#123;    let i &#x3D; 0    ctx.strokeStyle &#x3D; &#39;red&#39;    window.requestAnimationFrame(_draw)    function _draw () &#123;      let &#123;x, y, width, height&#125; &#x3D; rects[i++]      ctx.strokeRect(x, y, width, height)      if (i &lt; rects.length) &#123;          &#x2F;&#x2F; 和setTimeout类似，不过setTimeout需要指定时间，而window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘        window.requestAnimationFrame(_draw)      &#125; else &#123;        console.log(&#39;%cDONE&#39;, &#39;background-color: green; color: white; padding: 0.3em 0.5em;&#39;)      &#125;    &#125;  &#125;  function getAllRects () &#123;    const allElements &#x3D; document.querySelectorAll(&#39;*&#39;)    const rects &#x3D; []    const &#123;x: htmlX, y: htmlY&#125; &#x3D; document.documentElement.getBoundingClientRect()    allElements.forEach(element &#x3D;&gt; &#123;      const eachElRects &#x3D; Array.from(element.getClientRects()).filter(rect &#x3D;&gt; &#123;        return rect.width || rect.height      &#125;).map(rect &#x3D;&gt; &#123;        return &#123;          x: rect.x - htmlX,          y: rect.y - htmlY,          width: rect.width,          height: rect.height        &#125;      &#125;)      rects.push(...eachElRects)    &#125;)    return rects  &#125;&#125;()</code></pre></div><h3 id="捕捉过程和冒泡过程"><a href="#捕捉过程和冒泡过程" class="headerlink" title="捕捉过程和冒泡过程"></a>捕捉过程和冒泡过程</h3><p>在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。</p><p>addEventListener 有三个参数：</p><ul><li><p>事件名称；</p></li><li><p>事件处理函数；</p></li><li><p>捕获还是冒泡。</p></li></ul><p>事件处理函数不一定是函数，也可以是个 JavaScript 具有 handleEvent 方法的对象</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 自定义事件var evt &#x3D; new Event(&quot;look&quot;, &#123;&quot;bubbles&quot;:true, &quot;cancelable&quot;:false&#125;);document.dispatchEvent(evt);</code></pre></div><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">Event MDN讲解</a></p><h3 id="浏览器API"><a href="#浏览器API" class="headerlink" title="浏览器API"></a>浏览器API</h3><p>多看标准和文档，这块比较杂，后期有机会二刷</p><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p><img src="https://static001.geekbang.org/resource/image/6b/f2/6b5051c452af8c3db5fbb8ba6b9e34f2.jpg" alt="IMG"></p><p>Three.js 3D框架</p><p>GCanvas</p><p>拓展前端边界</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>计算机图形学</p><p>WebGL</p><p>TensorFlow</p><p>Weex 和 RN 虽然都叫 Hybird 但不太一样，前者适合大厂主要是嵌入 APP 中使用，后者更适合创业公司</p><p>最好的学习就是在项目中锻炼自己</p><p>专注 + 锻炼 + 利用周末</p><p>专注即工作时专注于工作，努力做好每次迭代，遇到难题迎难而上，工作时不开微信，勤用笔记安排日常工作并整理文档。</p><p>定期锻炼</p><p>牺牲周末和晚上时间</p><p>在职场上，除了提高技术能力外，提高表达能力也是突破瓶颈的主要点</p><blockquote><p>表达能力是形成自己的框架系统，有理有据并且逻辑清晰，而且能让外人听懂，大部分优秀的人都具备这样的能力。反观自己并没有这样的能力，所以我要努力提升这块，其中最重要的方法就是写作训练。</p></blockquote><p>通过写作搭建自身的知识框架，同时提高表达能力</p><p>正反馈机制和强健的体魄成为坚持的助力</p><p>resolve 在哪个宏任务中调用，对应的 then 里的微任务就属于哪个宏任务。宏任务没有从异步队列中取出，中间所碰到的所有微任务都属于这个宏任务</p><blockquote><p>框架不是赶时髦，追潮流，每个框架都有解决的问题，我觉得你该焦虑的不是你用的框架为什么这么老，而是你该知道这些新框架要解决什么问题，以及这些问题为什么在你的工作中不存在</p></blockquote><blockquote><p>在 promise 出现之前，javascript 并没有异步，有异步的是宿主环境</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/1.html"/>
    <url>/blog/1.html</url>
    
    <content type="html"><![CDATA[<p><code>并查集</code> 主要是用以解决<strong>元素分组</strong>的问题</p><p>其基本操作包括</p><ul><li>合并：把两个不相交的集合合并为一个集合</li><li>查询：查询两个元素时否在一个集合中</li></ul><p>在实际算法问题中有一个使用并查集的经典问题</p><ul><li><h4 id="祖先-亲戚-问题"><a href="#祖先-亲戚-问题" class="headerlink" title="祖先(亲戚)问题"></a>祖先(亲戚)问题</h4><ul><li>给出一系列的两两亲源关系，再合并形成总的祖先树图结构</li></ul></li></ul><p>1、在最开始我们有一系列的点[0, 1, 2, 3, 4, 5, 6, …]作为问题的元素，一个标号可以代表一个人，在最开始我们不知道他们的亲源关系时，大家都是孤立的节点，即<font color=blue>单元素集合</font></p><p>2、 随后我们得到一系列的关系列表例如[[0, 1], [0, 3], [3, 5], …]，该列表中的每个元素都是一个<font color=blue>关系</font>, 这些关系就如同两个元素(两个点)之间的有向线，通过不断的建立这些关系线，我们将会得到一个基本的关系图</p><p>3.、但是，这样的关系图只是标名了父子关系而不是祖先关系。因此就需要递归的继续寻找上一节点的祖先即找爸爸的爸爸，直到找到初代祖先。</p><p>4、 我们用一个数组来表示他们的祖先关系，<code>fa[i]=j</code>，表示<code>i</code>点的祖先是下标为<code>j</code>点的元素</p><ul><li>初始状态</li></ul><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fa[i] &#x3D; i;&#x2F;&#x2F; 初始时，每个人都是孤元素集合，此时关系指向自己</code></pre></div><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int find (x) &#123;   if (fa[x] &#x3D;&#x3D; x) &#123; &#x2F;&#x2F; 若祖先&#x3D;&#x3D;自己，自己就是根祖先   return x;   &#125; else &#123; &#x2F;&#x2F; 否则，继续往上找上一个祖先的祖先   fa[x] &#x3D; find(fa[x]); &#x2F;&#x2F; 路径压缩   return fa[x];   &#125;   &#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20210605133909705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FobHBwdGR5Zm4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><hr><p>基于上面的查询算法已经可以知道每个人的祖先了，但如果这个时候有两个家族打算合并，那么只要把两个家族的祖先变成父子关系，就如同两个数型结构，要合并的话，只有把一个树的根节点作为另一颗树的子节点就可以形成一个新的树型结构。</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void unionSet(int x, int y) &#123;  &#x2F;&#x2F; x 与 y 所在家族合并  x &#x3D; find(x);  y &#x3D; find(y);  fa[x] &#x3D; y;  &#x2F;&#x2F; 把 x 的祖先变成 y 的祖先的儿子</code></pre></div><ul><li>但两个祖先，谁当父谁当子会更好呢，还是都一样？</li></ul><p>当然是不一样的，两个家族的合并，从常理来说，肯定是家族人少的一家合到人多的一家会方便点，就树型结构来说，把树深度较低(或个数较少)的树作为另一颗深度大的子树可可以保持层数不变，同时在执行查找操作的用时更小，反过来的话树就会越来越深</p><p>因此我们需要额外的变量保存这些树的高度</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::vector&lt;int&gt; size(N, 1);  &#x2F;&#x2F; 记录并初始化子树的大小为 1void unionSet(int x, int y) &#123;  int xx &#x3D; find(x), yy &#x3D; find(y);  if (xx &#x3D;&#x3D; yy) return;  if (size[xx] &gt; size[yy])  &#x2F;&#x2F; 保证小的合到大的里    swap(xx, yy);  fa[xx] &#x3D; yy;  size[yy] +&#x3D; size[xx];&#125;</code></pre></div><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在查找的方法中采用了<code>路径压缩</code>的优化<br>在合并的方法中采用了<code>启发式</code>合并的优化</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>翻转卡片</title>
    <link href="/blog/57825.html"/>
    <url>/blog/57825.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.webhek.com/post/css-flip.html">记录自</a></p><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&quot;flip-container&quot; ontouchstart&#x3D;&quot;this.classList.toggle(&#39;hover&#39;);&quot;&gt;&lt;div class&#x3D;&quot;flipper&quot;&gt;&lt;div class&#x3D;&quot;front&quot;&gt;&lt;!-- 前面内容 --&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;back&quot;&gt;&lt;!-- 背面内容 --&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre></div><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* entire container, keeps perspective *&#x2F;.flip-container &#123;perspective: 1000;&#125;&#x2F;* flip the pane when hovered *&#x2F;.flip-container:hover .flipper, .flip-container.hover .flipper &#123;transform: rotateY(180deg);&#125;.flip-container, .front, .back &#123;width: 320px;height: 480px;&#125;&#x2F;* flip speed goes here *&#x2F;.flipper &#123;transition: 0.6s;transform-style: preserve-3d;position: relative;&#125;&#x2F;* hide back of pane during swap *&#x2F;.front, .back &#123;backface-visibility: hidden;position: absolute;top: 0;left: 0;&#125;&#x2F;* front pane, placed above back *&#x2F;.front &#123;z-index: 2;&#125;&#x2F;* back, initially hidden pane *&#x2F;.back &#123;transform: rotateY(180deg);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>H5</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>有趣的特效实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog/16107.html"/>
    <url>/blog/16107.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
